<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Ticuv Title in R&M Style -->
    <title>Ticuv's Sign-O-Matic (Probably His Tech Anyway)</title>
    <style>
        /* Import Fonts: "Luckiest Guy" for titles, Roboto for fallback */
        @import url('https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Roboto:wght@400;700&display=swap');

        :root {
            /* RICK & MORTY Color Palette */
            --rick-green: #97ce4c;
            --morty-yellow: #f0e14a;
            --portal-blue: #00b0c8;
            --interdimensional-purple: #aa6bd1;
            --slime-green: #c3ff5d;
            --dark-matter: #1e1e2f;
            --medium-dark: #2a2a3a;
            --off-white: #f0f0e0;
            --error-red: #ff4d4d;
            --outline-black: #1a1a1a;
            --glow-green: rgba(151, 206, 76, 0.7);
            --glow-blue: rgba(0, 176, 200, 0.7);
            --light-bg: #3a3a4a; /* Added for disabled button consistency */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Roboto', sans-serif; /* Readable fallback */
            background-color: var(--dark-matter);
            color: var(--off-white);
            line-height: 1.5;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 1.5rem 1rem;
            /* Chaotic Background from R&M style */
            background:
                linear-gradient(135deg, rgba(151, 206, 76, 0.1) 25%, transparent 25%) -50px 0,
                linear-gradient(225deg, rgba(170, 107, 209, 0.1) 25%, transparent 25%) -50px 0,
                linear-gradient(315deg, rgba(0, 176, 200, 0.1) 25%, transparent 25%),
                linear-gradient(45deg, rgba(240, 225, 74, 0.1) 25%, transparent 25%);
            background-size: 100px 100px;
            background-color: var(--dark-matter);
            overflow-x: hidden;
        }

        .container {
            background-color: rgba(42, 42, 58, 0.9);
            border: 4px solid var(--outline-black);
            border-radius: 10px; /* Squarish */
            padding: 1.5rem;
            max-width: 700px;
            width: 95%;
            text-align: center;
            box-shadow: 5px 5px 0px var(--outline-black); /* R&M hard shadow */
            margin-top: 1rem;
            transform: rotate(-1.5deg); /* R&M tilt */
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55); /* R&M bouncy */
        }
        .container:hover {
             transform: rotate(0.5deg) scale(1.01); /* R&M Wobble */
        }

        /* Use Funky font for key elements */
        h1, h2, h3, .button-style, .upload-label, .radio-group label, #signSelector {
            font-family: 'Luckiest Guy', cursive;
            letter-spacing: 1px;
        }

        h1 {
            /* Color from R&M green, adjust if needed for Ticuv */
            color: var(--rick-green);
            margin-bottom: 1.5rem;
            font-size: 2.8rem;
            /* Heavy Outline Text Shadow from R&M style */
            text-shadow:
               -2px -2px 0 var(--outline-black),
                2px -2px 0 var(--outline-black),
               -2px  2px 0 var(--outline-black),
                2px  2px 0 var(--outline-black),
                4px 4px 0 var(--interdimensional-purple);
            /* R&M Glow Animation */
            animation: pulse-glow-rick 4s infinite alternate;
        }

        @keyframes pulse-glow-rick { /* Keep R&M glow */
            from { text-shadow: -2px -2px 0 var(--outline-black), 2px -2px 0 var(--outline-black), -2px 2px 0 var(--outline-black), 2px 2px 0 var(--outline-black), 4px 4px 0 var(--interdimensional-purple), 0 0 15px var(--glow-green); }
            to { text-shadow: -2px -2px 0 var(--outline-black), 2px -2px 0 var(--outline-black), -2px 2px 0 var(--outline-black), 2px 2px 0 var(--outline-black), 4px 4px 0 var(--portal-blue), 0 0 25px var(--glow-blue); }
        }


        h2 { font-size: 1.8rem; color: var(--morty-yellow); margin-bottom: 1rem; text-shadow: 2px 2px 0 var(--outline-black);}
        h3 { font-size: 1.4rem; margin-top: 1.5rem; color: var(--portal-blue); text-shadow: 1px 1px 0 var(--outline-black);}

        p {
            color: var(--off-white); /* R&M brighter paragraph */
            margin-bottom: 1rem;
            font-size: 1rem;
        }
        .upload-section p { /* R&M upload text style */
            font-style: italic;
            color: var(--rick-green);
            opacity: 0.8;
        }

        /* Section Styling - R&M Dashed */
        .upload-section, .controls-section {
            margin-bottom: 1.5rem;
            border: 3px dashed var(--interdimensional-purple);
            padding: 1rem;
            border-radius: 5px; /* Sharper */
            background-color: rgba(0,0,0, 0.3);
            transition: all 0.3s ease;
            position: relative;
        }
        .upload-section.drag-over { /* R&M dragover */
             border-color: var(--slime-green);
             border-style: solid;
             background-color: rgba(195, 255, 93, 0.1);
             transform: scale(1.02);
        }

        /* Buttons & Labels - R&M Style */
        .button-style, .upload-label {
            display: inline-block;
            padding: 10px 20px;
            border: 3px solid var(--outline-black);
            border-radius: 5px; /* Squarish */
            cursor: pointer;
            font-size: 1.1rem;
            background-color: var(--morty-yellow); /* R&M Yellow */
            color: var(--outline-black);
            transition: all 0.15s ease-out;
            text-decoration: none;
            margin: 0.5rem;
            box-shadow: 3px 3px 0px var(--outline-black); /* R&M Hard shadow */
            text-shadow: 1px 1px 0 rgba(255,255,255,0.3);
        }
        .button-style:hover, .upload-label:hover {
            background-color: var(--rick-green); /* R&M Green hover */
            box-shadow: 4px 4px 0px var(--outline-black);
            transform: translate(-2px, -2px) rotate(1deg); /* R&M Jiggle */
        }
         .button-style:active, .upload-label:active {
            transform: translate(1px, 1px) rotate(0deg);
            box-shadow: 1px 1px 0px var(--outline-black);
         }


        #downloadButton {
            background-color: var(--portal-blue); /* R&M Blue */
            color: var(--off-white);
            text-shadow: 1px 1px 0 var(--outline-black);
        }
         #downloadButton:hover {
            background-color: var(--interdimensional-purple); /* R&M Purple hover */
            color: var(--off-white);
         }
         #downloadButton.disabled {
             background-color: var(--light-bg); /* Use the defined variable */
             border-color: #555;
             color: #888;
             cursor: crosshair; /* R&M cursor */
             opacity: 0.7;
             transform: none;
             box-shadow: 2px 2px 0px #444;
             pointer-events: none;
             text-shadow: none;
         }

        input[type="file"] { display: none; }

        /* Info & Error Messages - R&M Style */
        #imageInfo, #errorMessage {
            margin-top: 1rem;
            font-size: 1rem;
            min-height: 1.5em;
            font-weight: bold;
            color: var(--morty-yellow); /* R&M Yellow */
            transition: all 0.3s ease;
            text-shadow: 1px 1px 0 var(--outline-black);
        }
        #imageInfo.success {
            color: var(--slime-green); /* R&M Slime */
        }
        #errorMessage {
            color: var(--error-red); /* R&M Red */
            /* R&M Shake Animation */
            /* Removed default animation - will be added by JS if needed */
            /* animation: shake-rick 0.4s linear infinite; */
        }

        @keyframes shake-rick { /* Keep R&M shake */
            0%, 100% { transform: translateX(0) rotate(0); }
            25% { transform: translateX(-3px) rotate(-1deg); }
            50% { transform: translateX(3px) rotate(1deg); }
            75% { transform: translateX(-3px) rotate(-1deg); }
        }

        .hidden { display: none !important; }

        /* Preview Area - SQUARE */
        #previewArea {
            margin: 1.5rem auto;
            position: relative;
            width: 300px;
            height: 300px;
            border: 5px solid var(--portal-blue); /* R&M thick border */
            background-color: #000; /* R&M black bg */
            overflow: hidden;
            border-radius: 10px; /* BACK TO SQUARE-ISH */
            box-shadow: 0 0 15px var(--glow-blue), inset 0 0 10px rgba(0,0,0,0.6); /* Keep glow */
            animation: none; /* Remove portal swirl */
            filter: none; /* Remove hue rotate */
        }
        #previewCanvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 6px; /* Match parent slightly inner */
            object-fit: cover; /* Fill the square */
        }

        /* Radio Button Styling - R&M Style */
        .radio-group {
             display: flex;
             justify-content: center;
             gap: 1rem;
             flex-wrap: wrap;
             margin-top: 1rem;
        }
        .radio-group input[type="radio"] { display: none; }

        .radio-group label {
            display: inline-block;
            padding: 8px 15px;
            border: 3px solid var(--outline-black);
            border-radius: 20px; /* R&M Pill shape */
            cursor: pointer;
            background-color: var(--interdimensional-purple); /* R&M Purple */
            color: var(--off-white);
            transition: all 0.2s ease;
            font-size: 1rem;
            text-shadow: 1px 1px 0 var(--outline-black);
            box-shadow: 2px 2px 0 var(--outline-black); /* R&M Shadow */
        }
        .radio-group input[type="radio"]:checked + label {
            background-color: var(--rick-green); /* R&M Green selected */
            color: var(--outline-black);
            transform: scale(1.1);
            box-shadow: 3px 3px 0 var(--outline-black);
        }
         .radio-group label:hover {
             background-color: var(--portal-blue); /* R&M Blue hover */
             transform: translateY(-2px);
             box-shadow: 3px 4px 0 var(--outline-black);
         }
         .radio-group input[type="radio"]:focus-visible + label {
             outline: 3px dashed var(--morty-yellow); /* R&M focus */
             outline-offset: 3px;
         }

        /* Select Dropdown Styling - R&M Style */
        #signSelectorContainer {
            margin-top: 1.5rem;
        }
        #signSelector {
            padding: 10px 15px;
            background-color: var(--medium-dark);
            color: var(--rick-green); /* R&M Green text */
            border: 3px solid var(--outline-black);
            border-radius: 5px; /* R&M Square */
            font-size: 1.1rem;
            width: 85%;
            max-width: 400px;
            cursor: pointer;
            appearance: none;
            /* R&M Arrow */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%2397ce4c'%3E%3Cpolygon points='8,12 4,6 12,6' stroke='%231a1a1a' stroke-width='1.5'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 18px 18px;
            transition: all 0.2s ease;
            box-shadow: 2px 2px 0 var(--outline-black); /* R&M Shadow */
        }
        #signSelector:hover {
            border-color: var(--rick-green);
            background-color: var(--light-bg); /* Use the defined variable */
            box-shadow: 3px 3px 0 var(--outline-black);
        }
        #signSelector:focus {
             outline: 3px dashed var(--morty-yellow); /* R&M Focus */
             border-color: var(--rick-green);
        }

        /* Footer - R&M Style */
        footer {
            margin-top: 2rem;
            font-size: 0.9rem;
            color: var(--morty-yellow); /* R&M Yellow */
            opacity: 0.8;
            transform: rotate(1deg); /* R&M Tilt */
            text-shadow: 1px 1px 0 var(--outline-black);
        }
        footer a { /* Style the link if needed */
            color: var(--rick-green);
            text-decoration: underline dotted;
        }
         footer a:hover {
             color: var(--portal-blue);
         }

        /* Loader Style - R&M Theme */
        #loader {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            z-index: 1000;
            transform: translate(-50%, -50%); /* Center loader properly */
        }
        #loader::before { /* R&M Portal swirl */
            content: '';
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 5px solid transparent;
            border-top-color: var(--portal-blue);
            border-bottom-color: var(--rick-green);
            animation: spin-rick 1.2s cubic-bezier(0.6, 0, 0.4, 1) infinite;
            box-shadow: 0 0 15px var(--glow-blue), 0 0 10px var(--glow-green) inset;
        }

        @keyframes spin-rick { /* Keep R&M Spin */
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); border-top-color: var(--rick-green); border-bottom-color: var(--portal-blue); }
            100% { transform: rotate(360deg) scale(1); }
        }

        /* Responsive Adjustments - R&M Style */
        @media (max-width: 600px) {
            html { font-size: 14px; }
            body { padding: 1rem 0.5rem; }
             /* Straighten on mobile for usability */
            .container { padding: 1rem; transform: rotate(0); width: 98%; }
            .container:hover { transform: none; }
            h1 { font-size: 2.2rem; }
            h2 { font-size: 1.6rem; }
            h3 { font-size: 1.2rem; }
            .button-style, .upload-label { padding: 8px 15px; font-size: 1rem;}
            #previewArea { width: 200px; height: 200px; } /* Smaller square */
            .radio-group { gap: 0.5rem; }
            .radio-group label { padding: 6px 12px; font-size: 0.9rem;}
            #signSelector { width: 95%; font-size: 1rem; padding: 8px 12px;}
        }

    </style>
</head>
<body>
    <!-- Loader Element -->
    <div id="loader" class="hidden"></div>

    <div class="container">
        <!-- Ticuv Title -->
        <h1>Ticuv's Dimensional Sign-O-Matic</h1>
        <!-- Updated Intro Text with Ticuv -->
        <p>Alright, genius, upload your stupid 2048x2048 image. Let's see Ticuv's magic... or whatever.</p>

        <div id="uploadSection" class="upload-section">
            <!-- Updated Heading -->
            <h2>Step 1: GET THE IMAGE IN HERE!</h2>
            <!-- Updated Button Text -->
            <label for="imageUpload" class="upload-label">Choose File, SCHWACKO!</label>
            <input type="file" id="imageUpload" accept=".jpg, .jpeg, .png">
            <!-- Updated Drag & Drop Text -->
            <p>Or just... *uurp*... drag it here, like a caveman.</p>
            <!-- Updated Info Text -->
            <div id="imageInfo">Waiting for your pathetic image...</div>
            <div id="errorMessage" class="hidden"></div>
        </div>

         <!-- Preview Area - SQUARE -->
         <div id="previewArea" class="hidden">
            <canvas id="previewCanvas" width="300" height="300"></canvas>
         </div>

        <div id="controlsSection" class="controls-section hidden">
            <!-- Updated Heading -->
            <h2>Step 2: WHICH *burp* DIMENSION?!</h2>
            <div class="radio-group">
                <!-- Keep IDs/Values same for JS -->
                <input type="radio" id="categoryGHN" name="category" value="GHN">
                <label for="categoryGHN">GHN Garbage Heap</label>

                <input type="radio" id="categoryAHC" name="category" value="AHC">
                <label for="categoryAHC">AHC Clown Fiesta</label>
            </div>

            <div id="signSelectorContainer" class="hidden">
                 <!-- ID for dynamic text update -->
                 <h3 id="signPrompt">Step 3: Pick a sign, you glorious pixel sponge!</h3>
                <select id="signSelector">
                    <!-- Options populated by JS -->
                </select>
            </div>
        </div>

         <!-- Updated Download Button Text -->
         <button id="downloadButton" class="button-style hidden disabled">Download This Beauty!</button>

         <!-- Hidden Canvas for FINAL composition -->
         <canvas id="finalCanvas" width="2048" height="2048" style="display: none;"></canvas>


         <!-- Ticuv Footer with R&M Vibe -->
         <footer>Invented by Ticuv (probably). Don't mess it up, you plumbus!</footer>
    </div>

    <script>
        // Wrap script in an IIFE
        (function() {
            // --- DOM Element Selections (Keep these the same) ---
            const imageUpload = document.getElementById('imageUpload');
            const imageInfo = document.getElementById('imageInfo');
            const errorMessage = document.getElementById('errorMessage');
            const controlsSection = document.getElementById('controlsSection');
            const previewArea = document.getElementById('previewArea');
            const previewCanvas = document.getElementById('previewCanvas');
            const finalCanvas = document.getElementById('finalCanvas');
            const categoryRadios = document.querySelectorAll('input[name="category"]');
            const signSelectorContainer = document.getElementById('signSelectorContainer');
            const signSelector = document.getElementById('signSelector');
            const downloadButton = document.getElementById('downloadButton');
            const signPrompt = document.getElementById('signPrompt'); // Target for quips
            const uploadSection = document.getElementById('uploadSection');
            const loader = document.getElementById('loader');

            // --- Contexts ---
            const previewCtx = previewCanvas.getContext('2d');
            const finalCtx = finalCanvas.getContext('2d');

            // --- Constants and State ---
            const REQUIRED_WIDTH = 2048;
            const REQUIRED_HEIGHT = 2048;
            let currentCategory = null;
            let baseImageDataUrl = null;
            let isProcessing = false;

            // --- Funny Quips (Replace "Morty") ---
            const funnyQuips = [
                "Pick a sign, you glorious pixel sponge!",
                "Pick a sign, or the space hamsters revolt!",
                "Choose wisely... the multiverse is watching (and judging).",
                "Select a sign, *burp*, before Ticuv gets annoyed.",
                "Overlay this garbage, c'mon!",
                "Just pick one, fleeb! It's not that hard!",
                "This sign better be good, or you're getting squanched.",
                "Designate the emblem, or face the wrath of Ticuv!"
            ];

            // --- Sign Data ---
            // Updated to use relative paths from the GitHub repository structure
            const signData = {
                AHC: [
                    { name: "AHC - Ape Sign", url: "images/AHC/ape.png" },
                    // You might want to download and add the other AHC images locally too
                    { name: "AHC - Blips and Chitz Placeholder", url: "images/placeholderAHC2.png" }, // Needs local file
                    { name: "AHC - Anatomy Park Placeholder", url: "images/placeholderAHC3.png" }  // Needs local file
                ],
                GHN: [
                    { name: "GHN - Daniel Sign", url: "images/GHN/daniel.png" },
                    { name: "GHN - Duko Sign", url: "images/GHN/duko.png" },
                    { name: "GHN - MC Sign", url: "images/GHN/mc.png" },
                    // You might want to add a 4th GHN image locally
                    { name: "GHN - Placeholder Zone", url: "images/placeholderGHN4.png" } // Needs local file
                ]
            };


            // --- Event Listeners (Keep functional) ---
            imageUpload.addEventListener('change', handleFileSelect);
            categoryRadios.forEach(radio => radio.addEventListener('change', handleCategoryChange));
            signSelector.addEventListener('change', handleSignChange);
            downloadButton.addEventListener('click', handleDownload);
            uploadSection.addEventListener('dragover', handleDragOver);
            uploadSection.addEventListener('dragleave', handleDragLeave);
            uploadSection.addEventListener('drop', handleDrop);

            // ==================================
            //        CORE FUNCTIONS
            // ==================================

            function handleFileSelect(event) {
                const file = event.target.files ? event.target.files[0] : null;
                if (file) {
                    processImageFile(file);
                }
            }

            function processImageFile(file) {
                 if (isProcessing) return;
                 setProcessing(true);
                 showLoader();
                 resetInterfaceOnUpload();
                 disableDownloadButton("Checking your junk..."); // Ticuv text

                if (!file) {
                    updateInfo('No file? Come on, shleemypants!');
                    hideLoader();
                    setProcessing(false);
                    return;
                }

                if (!['image/jpeg', 'image/png'].includes(file.type)) {
                    showError('Wrong file type, smoothbrain! PNG or JPG!');
                    resetUploadInput();
                    hideLoader();
                    setProcessing(false);
                    return;
                }

                updateInfo(`Analyzing "${file.name}"... Don't Bork it up.`);

                const reader = new FileReader();
                reader.onload = function(e) {
                    const tempImg = new Image();
                    tempImg.onload = function() {
                        if (tempImg.naturalWidth !== REQUIRED_WIDTH || tempImg.naturalHeight !== REQUIRED_HEIGHT) {
                            showError(`WRONG SIZE! Need ${REQUIRED_WIDTH}x${REQUIRED_HEIGHT}px! You brought ${tempImg.naturalWidth}x${tempImg.naturalHeight}px junk!`);
                            resetUploadInput();
                            clearCanvas(previewCtx);
                            clearCanvas(finalCtx);
                            previewArea.classList.add('hidden');
                        } else {
                            hideError();
                            baseImageDataUrl = e.target.result;
                            updateInfo(`"${file.name}" validated! Barely. Pick a dimension!`, true);
                            clearCanvas(previewCtx);
                            previewCtx.drawImage(tempImg, 0, 0, previewCanvas.width, previewCanvas.height);
                            previewArea.classList.remove('hidden');
                            controlsSection.classList.remove('hidden');
                            // Important: Reset sign selection and disable download until a sign is chosen/applied
                            signSelector.innerHTML = '';
                            signSelectorContainer.classList.add('hidden');
                            categoryRadios.forEach(radio => radio.checked = false);
                            currentCategory = null;
                            disableDownloadButton("Pick a dimension first!");
                        }
                        hideLoader();
                        setProcessing(false);
                    };
                    tempImg.onerror = function() {
                        showError('This image is busted! Like your last invention.');
                        resetInterface(); // Full reset on critical image load error
                        hideLoader();
                        setProcessing(false);
                    };
                    tempImg.src = e.target.result;
                };
                reader.onerror = function() {
                    showError('File Read Error! Dropped it in the portal fluid?');
                    resetInterface(); // Full reset on file read error
                    hideLoader();
                    setProcessing(false);
                };
                reader.readAsDataURL(file);
            }

            function handleCategoryChange(event) {
                if (isProcessing || !baseImageDataUrl) return; // Don't process if busy or no base image
                currentCategory = event.target.value;
                console.log('Dimension selected:', currentCategory);
                disableDownloadButton("Pick the sign, slowpoke!");
                updateSignPrompt();

                populateSignSelector(currentCategory);
                signSelectorContainer.classList.remove('hidden');

                // Automatically apply the first sign of the selected category
                const defaultSignUrl = signData[currentCategory]?.[0]?.url;
                if (defaultSignUrl) {
                    applySign(defaultSignUrl);
                } else {
                     console.error("No default sign found for category:", currentCategory);
                     showError("Error! No signs defined for this dimension! Ticuv is slacking.");
                     // Clear potential previous preview and disable download
                     clearCanvas(previewCtx);
                     clearCanvas(finalCtx); // Also clear final canvas
                     finalCtx.drawImage(baseImage, 0, 0, finalCanvas.width, finalCanvas.height); // Redraw base image
                     previewCtx.drawImage(baseImage, 0, 0, previewCanvas.width, previewCanvas.height); // Update preview with just base
                     disableDownloadButton("No signs here!");
                }
            }

            function handleSignChange() {
                if (isProcessing || !baseImageDataUrl) return;
                const selectedSignUrl = signSelector.value;
                if (selectedSignUrl) {
                     applySign(selectedSignUrl);
                }
            }

             function populateSignSelector(category) {
                signSelector.innerHTML = ''; // Clear previous options
                const signs = signData[category];
                if (!signs || signs.length === 0) {
                    // Add a disabled placeholder if no signs exist
                    const option = document.createElement('option');
                    option.disabled = true;
                    option.selected = true;
                    option.textContent = "No signs found for this category!";
                    signSelector.appendChild(option);
                    signSelector.disabled = true; // Disable selector
                    return;
                };

                signSelector.disabled = false; // Ensure selector is enabled
                signs.forEach((sign) => {
                    const option = document.createElement('option');
                    option.value = sign.url;
                    option.textContent = sign.name;
                    // Basic check if URL looks like a placeholder or non-existent local file based on previous code
                    if (sign.url.includes('placeholder') || !sign.url.endsWith('.png')) {
                         option.disabled = true;
                         option.textContent += " (Missing)"; // Indicate missing
                    }
                    signSelector.appendChild(option);
                });

                // Select the first available (non-disabled) option if possible
                const firstAvailableOption = signSelector.querySelector('option:not([disabled])');
                if (firstAvailableOption) {
                    signSelector.value = firstAvailableOption.value;
                } else if (signSelector.options.length > 0) {
                     signSelector.selectedIndex = 0; // Select the first (likely disabled) if none are available
                }
            }

            // No changes needed in loadImagePromise, it should handle relative paths fine
             function loadImagePromise(src, crossOrigin = null) {
                return new Promise((resolve, reject) => {
                    if (!src || src === '#') return reject(new Error('Bad image source. Elementary, my dear Flargan.'));
                    const img = new Image();
                    // IMPORTANT: Do NOT set crossOrigin for relative paths (same-origin images)
                    // Only set it if the src is an absolute URL (http:// or https://)
                    if (crossOrigin && (src.startsWith('http://') || src.startsWith('https://'))) {
                         img.crossOrigin = crossOrigin;
                    }
                    img.onload = () => resolve(img);
                    img.onerror = (err) => {
                        console.error(`Failed loading image: ${src}`, err);
                        // Provide a more specific error for local files
                        const errorMsg = (src.startsWith('http') ?
                            `Image load failed! Check the interdimensional router! (${src.substring(0, 60)}...)` :
                            `Image load failed! Is "${src}" in the correct 'images' folder and uploaded to GitHub?`);
                        reject(new Error(errorMsg));
                    };
                    img.src = src;
                });
            }

            async function applySign(signUrl) {
                if (!baseImageDataUrl) {
                    showError("Upload an image FIRST! Are you a Gazorpian?");
                    return;
                }
                if (!signUrl || signUrl.includes('placeholder')) { // Also check for placeholder URLs
                    showError("Invalid or placeholder sign URL selected. Can't apply.");
                    // Reset preview to show only base image
                    const baseImage = await loadImagePromise(baseImageDataUrl);
                    clearCanvas(finalCtx);
                    finalCtx.drawImage(baseImage, 0, 0, finalCanvas.width, finalCanvas.height);
                    clearCanvas(previewCtx);
                    previewCtx.drawImage(finalCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
                    disableDownloadButton("Select a valid sign!");
                    return;
                }
                 if (isProcessing) return;

                 setProcessing(true);
                 showLoader();
                 console.log(`Applying sign: ${signUrl}`);
                 updateInfo("Slapping that sign on... *burp*... Ticuv style.");
                 hideError();
                 disableDownloadButton("Rendering... Don't touch anything!");

                try {
                    // Load base image first to always have it available
                    const baseImage = await loadImagePromise(baseImageDataUrl);

                    // Attempt to load the sign image
                    const signImage = await loadImagePromise(signUrl); // No crossOrigin needed for relative paths

                    // Clear and draw base image first
                    clearCanvas(finalCtx);
                    finalCtx.drawImage(baseImage, 0, 0, finalCanvas.width, finalCanvas.height);

                    // Draw the sign overlay
                    let dx = 0; let dy = 0;
                    finalCtx.drawImage(signImage, dx, dy, finalCanvas.width, finalCanvas.height);
                    console.log('Final canvas done.');

                    // Since images are same-origin now, tainting shouldn't occur.
                    // We can directly enable download and update preview.
                    enableDownloadButton();
                    updateInfo("Overlay complete! Bask in its mediocre glory!", true);

                    clearCanvas(previewCtx);
                    previewCtx.drawImage(finalCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
                    console.log('Preview canvas updated.');

                } catch (error) {
                    // Catch errors from loadImagePromise (e.g., image not found)
                    console.error('Error during image processing:', error);
                    showError(`Sign Processing FAILED! ${error.message}. Ticuv saw that.`);

                    // Reset preview to show only base image on error
                    try {
                        const baseImgForError = await loadImagePromise(baseImageDataUrl);
                        clearCanvas(previewCtx);
                        clearCanvas(finalCtx);
                        finalCtx.drawImage(baseImgForError, 0, 0, finalCanvas.width, finalCanvas.height);
                        previewCtx.drawImage(baseImgForError, 0, 0, previewCanvas.width, previewCanvas.height);
                    } catch (baseLoadError) {
                         console.error("Failed to load base image even for error display:", baseLoadError);
                         clearCanvas(previewCtx); // Clear everything if base fails too
                         clearCanvas(finalCtx);
                    }

                    disableDownloadButton("Error! Try Again?");
                } finally {
                     hideLoader();
                     setProcessing(false);
                }
            }

            // No changes needed in handleDownload, as canvas tainting should be resolved
            function handleDownload() {
                 if (downloadButton.classList.contains('disabled') || isProcessing) return;

                 try {
                     // Check if final canvas actually has content (basic check)
                     // A more robust check might be needed, but this catches empty canvas.
                      const pixelData = finalCtx.getImageData(0, 0, 1, 1).data;
                      if (pixelData[3] === 0 && baseImageDataUrl == null) { // Check alpha and if base image was ever loaded
                          throw new Error("Canvas is empty or only contains transparent pixels!");
                      }

                     const dataURL = finalCanvas.toDataURL('image/png');
                     const link = document.createElement('a');

                     let filename = 'Ticuvs-Magnificent-Overlay.png';
                     const selectedSignOption = signSelector.options[signSelector.selectedIndex];
                     if (currentCategory && selectedSignOption?.textContent && !selectedSignOption.disabled) { // Check if option is not disabled
                         const slugify = (text) => text.toLowerCase()
                           .replace(/\s+/g, '-') // Replace spaces with -
                           .replace(/-*\(missing\)-*/g, '') // Remove (missing) indicator
                           .replace(/[^\w-]+/g, '') // Remove all non-word chars except -
                           .replace(/--+/g, '-') // Replace multiple - with single -
                           .replace(/^-+/, '') // Trim - from start
                           .replace(/-+$/, ''); // Trim - from end
                         filename = `Ticuv-${currentCategory}-Sign-${slugify(selectedSignOption.textContent)}.png`;
                     }

                     link.href = dataURL;
                     link.download = filename;

                     document.body.appendChild(link);
                     link.click();
                     document.body.removeChild(link);
                     console.log('Download initiated:', filename);
                     updateInfo("Downloaded! Now scram!", true);

                 } catch (error) {
                      console.error('Canvas download failed:', error);
                       // SecurityError should not happen with same-origin images
                      showError(`Download FAILED! ${error.message}. Maybe the canvas hates you.`);
                 }
            }


            // ==================================
            //      DRAG & DROP HANDLERS (Keep functional)
            // ==================================

            function handleDragOver(event) {
                event.preventDefault();
                event.stopPropagation();
                uploadSection.classList.add('drag-over');
            }

            function handleDragLeave(event) {
                event.preventDefault();
                event.stopPropagation();
                uploadSection.classList.remove('drag-over');
            }

            function handleDrop(event) {
                event.preventDefault();
                event.stopPropagation();
                uploadSection.classList.remove('drag-over');

                const files = event.dataTransfer.files;
                if (files.length > 0) {
                    // Set the files property of the hidden file input
                    imageUpload.files = files;
                     // Trigger the change event manually
                    const changeEvent = new Event('change', { bubbles: true });
                    imageUpload.dispatchEvent(changeEvent);
                    // processImageFile(files[0]); // No longer needed directly, handled by change event
                }
            }

            // ==================================
            //        UI HELPER FUNCTIONS
            // ==================================

            function showError(message) {
                errorMessage.textContent = `Error! ${message}`;
                errorMessage.classList.remove('hidden');
                imageInfo.classList.remove('success'); // Ensure info text isn't styled as success
                // Start shake animation only when an error is shown
                errorMessage.style.animation = 'shake-rick 0.4s linear infinite';
            }

            function hideError() {
                errorMessage.classList.add('hidden');
                errorMessage.textContent = '';
                errorMessage.style.animation = 'none'; // Stop animation when hiding
            }

            function updateInfo(message, isSuccess = false) {
                 imageInfo.textContent = message;
                 imageInfo.className = isSuccess ? 'success' : '';
                 // If we're updating info (especially success), hide any previous error
                 if (!errorMessage.classList.contains('hidden')) {
                    hideError();
                 }
            }

            function resetUploadInput() {
                imageUpload.value = ''; // Clears the selected file
            }

            function clearCanvas(context) {
                 context.clearRect(0, 0, context.canvas.width, context.canvas.height);
            }

            function enableDownloadButton() {
                downloadButton.classList.remove('hidden', 'disabled');
                downloadButton.title = "Click it already!";
            }

            function disableDownloadButton(reason = "Working... Don't rush genius!") {
                // Make sure button is visible before disabling if needed
                if (controlsSection.classList.contains('hidden')) {
                     downloadButton.classList.add('hidden');
                } else {
                     downloadButton.classList.remove('hidden');
                }
                downloadButton.classList.add('disabled');
                downloadButton.title = reason;
            }

            function showLoader() {
                 loader.classList.remove('hidden');
            }

            function hideLoader() {
                 loader.classList.add('hidden');
            }

             function setProcessing(state) {
                 isProcessing = state;
                 imageUpload.disabled = state;
                 categoryRadios.forEach(r => r.disabled = state);
                 signSelector.disabled = state;
                 // Also disable download button while processing
                 if (state) {
                    disableDownloadButton("Processing...");
                 } else {
                    // Re-evaluate if download should be enabled when processing finishes
                    // It should only be enabled if applySign was successful
                    if (!downloadButton.title.includes("Error") && !downloadButton.title.includes("Tainted") && !downloadButton.title.includes("Select") && !downloadButton.title.includes("Pick")) {
                       // Careful check, might need refinement based on disable reasons
                       // EnableDownloadButton() is called specifically in applySign on success now.
                    }
                 }
            }

            function updateSignPrompt() {
                 const randomIndex = Math.floor(Math.random() * funnyQuips.length);
                 signPrompt.textContent = `Step 3: ${funnyQuips[randomIndex]}`;
            }

            /** Full interface reset */
            function resetInterface() {
                 hideError();
                 controlsSection.classList.add('hidden');
                 previewArea.classList.add('hidden');
                 signSelectorContainer.classList.add('hidden');
                 downloadButton.classList.add('hidden','disabled');
                 baseImageDataUrl = null;
                 clearCanvas(previewCtx);
                 clearCanvas(finalCtx);
                 categoryRadios.forEach(radio => { radio.checked = false; radio.disabled = false; });
                 signSelector.innerHTML = '';
                 signSelector.disabled = false;
                 currentCategory = null;
                 updateInfo('Waiting for your pathetic image...');
                 resetUploadInput();
                 imageUpload.disabled = false;
                 setProcessing(false);
                 hideLoader();
             }

             /** Partial reset for new upload attempt */
             function resetInterfaceOnUpload() {
                 hideError();
                 // Keep controls hidden until image is validated
                 controlsSection.classList.add('hidden');
                 signSelectorContainer.classList.add('hidden');
                 previewArea.classList.add('hidden');
                 downloadButton.classList.add('hidden', 'disabled');
                 baseImageDataUrl = null; // Clear previous base image data
                 clearCanvas(previewCtx);
                 clearCanvas(finalCtx);
                 // Don't reset radios/selector yet, wait for validation
                 currentCategory = null;
                 updateInfo('Processing upload... Don\'t break Ticuv\'s stuff.');
             }

            // --- Initial State Setup ---
            resetInterface(); // Start clean (and chaotic Ticuv style)

        })(); // End of IIFE
    </script>

</body>
</html>
