<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>NFT Sign Generator (Ticuv Style Enhanced)</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.2/dist/ethers.umd.min.js"></script>

    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Roboto:wght@400;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&family=Indie+Flower&family=Rubik+Moonrocks&display=swap" rel="stylesheet">

    <style>
        /* ======================================== */
        /* CSS Styles (Ticuv Style - Enhanced)    */
        /* ======================================== */

        :root {
            /* Color Palette */
            --rick-green: #97ce4c; --morty-yellow: #f0e14a; --portal-blue: #00b0c8;
            --interdimensional-purple: #aa6bd1; --slime-green: #c3ff5d; --dark-matter: #1e1e2f;
            --medium-dark: #2a2a3a; --light-bg: #3a3a4a; --input-bg: #3b3b50;
            --off-white: #f0f0e0; --error-red: #ff4d4d; --outline-black: #1a1a1a;
            --glow-green: rgba(151, 206, 76, 0.7); --glow-blue: rgba(0, 176, 200, 0.7);
            --glow-purple: rgba(170, 107, 209, 0.5);
            --disabled-text: #888; --disabled-border: #555; --disabled-shadow: #444;
            --handle-active-bg: yellow; --handle-image-active-bg: cyan;

            /* UI adjustments */
            --control-padding: 0.5rem 0.7rem;
            --control-gap: 5px 8px;
            --button-padding: 6px 12px;
            --button-font-size: 0.85rem;
            --input-padding: 5px 8px;
            --input-font-size: 0.85rem;
            --label-font-size: 0.9rem;
            --handle-size: 26px;
            --handle-icon-size: 16px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { font-size: 15px; scroll-behavior: smooth; }

        body {
            font-family: 'Roboto', sans-serif; background-color: var(--dark-matter); color: var(--off-white);
            line-height: 1.4; display: flex; justify-content: center; align-items: flex-start;
            min-height: 100vh; padding: 0.5rem 0.3rem;
            background-image: repeating-linear-gradient(45deg, rgba(42, 42, 58, 0.8) 0, rgba(42, 42, 58, 0.8) 20px, transparent 20px, transparent 40px),
                              repeating-linear-gradient(-45deg, rgba(42, 42, 58, 0.8) 0, rgba(42, 42, 58, 0.8) 20px, transparent 20px, transparent 40px);
            background-size: 56px 56px; overflow-x: hidden;
        }

        .main-container {
            background-color: var(--medium-dark); border: 3px solid var(--interdimensional-purple);
            border-radius: 12px; padding: 0.8rem;
            max-width: 650px;
            width: 98%; text-align: center; box-shadow: 4px 4px 0px var(--outline-black), 0 0 15px rgba(0,0,0,0.4);
            margin: 0.4rem auto 0 auto;
            transform: rotate(-0.5deg); transition: transform 0.3s ease-out;
            display: flex; flex-direction: column; align-items: center;
        }
        .main-container:hover { transform: rotate(0.1deg) scale(1.005); }

        h3 {
            font-family: 'Luckiest Guy', cursive; font-size: 1.6rem;
            color: var(--rick-green);
            text-shadow: -1px -1px 0 var(--outline-black), 1px -1px 0 var(--outline-black), -1px 1px 0 var(--outline-black), 1px 1px 0 var(--outline-black), 2px 2px 0 var(--interdimensional-purple);
            margin-bottom: 0.6rem;
            letter-spacing: 0.5px;
        }

        #controls {
            width: 100%; background: none; padding: 0; border-radius: 0;
            margin-bottom: 0.5rem;
            display: flex; flex-direction: column; gap: 0.6rem;
            align-items: stretch;
        }

        .control-group {
            border: 2px dashed var(--morty-yellow); padding: var(--control-padding);
            border-radius: 10px; background-color: rgba(0,0,0, 0.2); display: flex;
            flex-wrap: wrap; justify-content: center; align-items: center; gap: var(--control-gap);
        }
         .text-editing-group { flex-direction: column; align-items: stretch; }
         .text-editing-group .row { display: flex; flex-wrap: wrap; gap: var(--control-gap); align-items: center; justify-content: flex-start; }
         .text-editing-group .row:not(:last-child){ margin-bottom: 5px; }
         .text-editing-group .row label { flex-shrink: 0; margin-right: 5px;}
         .text-editing-group .row .spacer { flex-grow: 1; min-width: 5px; }
         .text-editing-group input[type="text"] { flex-grow: 1; min-width: 120px; }
         .text-editing-group select { min-width: 100px; }

        label {
            font-family: 'Luckiest Guy', cursive; color: var(--portal-blue);
            font-size: var(--label-font-size); margin-right: 3px;
            text-shadow: 1px 1px 0 var(--outline-black); white-space: nowrap;
        }

        input[type="text"], input[type="number"], select {
            font-family: 'Roboto', sans-serif; border: 2px solid var(--outline-black);
            border-radius: 6px; padding: var(--input-padding); font-size: var(--input-font-size);
            background-color: var(--input-bg); color: var(--morty-yellow);
            box-shadow: inset 1px 1px 0px rgba(0,0,0,0.4); transition: all 0.2s ease;
        }
        input[type="number"] { max-width: 65px; text-align: center; flex-grow: 0; flex-shrink: 0; }
        select {
            appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23f0e14a'%3E%3Cpolygon points='8,12 4,6 12,6' stroke='%231a1a1a' stroke-width='1.5'/%3E%3C/svg%3E");
            background-repeat: no-repeat; background-position: right 8px center; background-size: 16px 16px;
            padding-right: 30px; cursor: pointer; flex-grow: 1; min-width: 100px;
        }
        input:focus, select:focus {
            outline: none; box-shadow: inset 1px 1px 0px rgba(0,0,0,0.4), 0 0 0 2px var(--portal-blue);
        }
        input[type="color"] {
            width: 40px; height: 30px; padding: 2px; border: 2px solid var(--outline-black); border-radius: 6px;
            background-color: var(--input-bg); cursor: pointer;
            transition: transform 0.15s ease-out; vertical-align: middle;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 3px; }
        input[type="color"]::-moz-color-swatch { border: none; border-radius: 3px; }
        input[type="color"]:hover:not(:disabled) { transform: scale(1.05); }

        input[type="file"] { font-family: 'Roboto', sans-serif; font-size: 0.75rem; color: var(--off-white); max-width: 200px; }
        input[type="file"]::file-selector-button {
            font-family: 'Roboto', sans-serif; font-weight: 700;
            font-size: var(--button-font-size);
            padding: var(--button-padding);
            border-radius: 8px;
            border: 2px solid var(--outline-black);
            background-color: var(--interdimensional-purple);
            color: var(--off-white);
            box-shadow: 2px 2px 0px var(--outline-black);
            cursor: pointer;
            transition: all 0.15s ease-out;
            margin-right: 10px;
        }
        input[type="file"]::file-selector-button:hover:not(:disabled) { transform: translateY(-1px) scale(1.02); box-shadow: 3px 3px 0px var(--outline-black); }
        input[type="file"]::file-selector-button:active:not(:disabled) { transform: translateY(1px) scale(0.98); box-shadow: 1px 1px 0px var(--outline-black); }

        button {
            font-family: 'Roboto', sans-serif; font-weight: 700;
            font-size: var(--button-font-size);
            padding: var(--button-padding);
            border-radius: 8px;
            border: 2px solid var(--outline-black);
            box-shadow: 2px 2px 0px var(--outline-black);
            cursor: pointer;
            transition: all 0.15s ease-out;
            user-select: none;
            text-align: center;
            vertical-align: middle;
            white-space: nowrap;
        }
        #loadNftBtn { background-color: var(--portal-blue); color: var(--off-white); }
        #applyOverlayBtn { background-color: var(--rick-green); color: var(--outline-black); }
        #addTextBtn, #addImageBtn { background-color: var(--morty-yellow); color: var(--outline-black); }
        #removeBtn { background-color: var(--error-red); color: var(--off-white); }
        #saveBtn { background-color: var(--slime-green); color: var(--outline-black); }

        button:hover:not(:disabled) { transform: translateY(-1px) scale(1.02); box-shadow: 3px 3px 0px var(--outline-black); }
        button:active:not(:disabled) { transform: translateY(1px) scale(0.98); box-shadow: 1px 1px 0px var(--outline-black); }

        input:disabled, select:disabled, button:disabled,
        input[type="file"]:disabled::file-selector-button {
            background-color: var(--light-bg); color: var(--disabled-text); border-color: var(--disabled-border);
            box-shadow: 1px 1px 0px var(--disabled-shadow); cursor: not-allowed; text-shadow: none; transform: none;
        }
        select:disabled { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23888888'%3E%3Cpolygon points='8,12 4,6 12,6' stroke='%23555555' stroke-width='1.5'/%3E%3C/svg%3E"); }
        input[type="color"]:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        input[type="file"]:disabled { color: var(--disabled-text); }

        #nftStatus {
            width: 100%; text-align: center; font-style: italic; min-height: 1.4em; margin: 4px 0;
            font-size: 0.85rem; color: var(--morty-yellow); text-shadow: 1px 1px 0 var(--outline-black);
            padding: 0 5px; word-wrap: break-word;
        }
        #nftStatus.error { color: var(--error-red); }
        #nftStatus.success { color: var(--slime-green); }

        #final-actions { display: flex; justify-content: center; gap: 10px; width: 100%; margin-bottom: 0.4rem; }

        #canvas-container {
            width: 100%; max-width: 500px; aspect-ratio: 1 / 1; margin: 0 auto; position: relative;
            cursor: default; touch-action: none; overflow: hidden; border: 3px solid var(--portal-blue);
            background-color: #000; border-radius: 8px; box-shadow: 0 0 12px var(--glow-blue), inset 0 0 8px rgba(0,0,0,0.7);
        }
        canvas { display: block; width: 100%; height: 100%; object-fit: contain; background-color: var(--medium-dark); border: none; border-radius: 6px; }

        .textOverlay, .imgOverlay { position: absolute; transform-origin: center center; user-select: none; touch-action: none; cursor: grab; transform: translate(-50%, -50%) rotate(0deg); padding: 3px; box-sizing: border-box; }
        .textOverlay { white-space: nowrap; font-weight: bold; z-index: 10; }
        .imgOverlay { z-index: 20; border: 1px dashed transparent; }
        .textOverlay.active { outline: 2px dashed var(--handle-active-bg); z-index: 100; cursor: grabbing; }
        .imgOverlay.active { outline: 2px dashed var(--handle-image-active-bg); z-index: 101; cursor: grabbing; }

        /* --- Styling for ALL Handles --- */
        .textOverlay .rotation-handle,
        .imgOverlay .rotation-handle,
        .imgOverlay .resize-handle {
            position: absolute;
            width: var(--handle-size);
            height: var(--handle-size);
            border-radius: 50%;
            border: 2px solid var(--outline-black);
            display: none;
            pointer-events: auto;
            touch-action: none;
            font-family: sans-serif;
            line-height: calc(var(--handle-size) - 4px);
            text-align: center;
            box-shadow: 1px 1px 0 var(--outline-black);
            background-color: transparent;
            color: var(--outline-black);
            user-select: none;
            transform-origin: center center;
        }

        /* Show handles only when the parent overlay is active */
        .textOverlay.active .rotation-handle,
        .imgOverlay.active .rotation-handle,
        .imgOverlay.active .resize-handle {
            display: block;
        }

        /* --- Rotation Handle Specific Styles (Text & Image) --- */
        .textOverlay .rotation-handle,
        .imgOverlay .rotation-handle {
            bottom: calc(-1 * var(--handle-size) - 4px);
            left: 50%;
            transform: translateX(-50%);
            cursor: alias;
            font-size: var(--handle-icon-size);
            color: var(--handle-active-bg);
            text-shadow: 1px 1px 1px var(--outline-black);
        }
        .imgOverlay .rotation-handle {
            color: var(--handle-image-active-bg);
        }

        /* --- Resize Handle Specific Styles (Image Only) --- */
        .imgOverlay .resize-handle {
            /* Position */
            left: calc(-0.5 * var(--handle-size) - 2px);
            bottom: calc(-0.5 * var(--handle-size) - 2px);
            cursor: nesw-resize;

            /* Visuals */
            font-size: calc(var(--handle-icon-size) * 1.1);
            background-color: rgba(195, 255, 93, 0.6);
            color: var(--outline-black);
            text-shadow: none;
            transition: background-color 0.2s ease, transform 0.1s ease;

            /* === ROTATION ADDED (45deg) === */
            transform: rotate(45deg);
        }

        /* Hover effect for resize handle */
        .imgOverlay .resize-handle:hover {
            background-color: var(--slime-green);
            /* Combine rotation and scale */
            transform: rotate(45deg) scale(1.1);
        }

        /* Active (pressed) effect for resize handle */
        .imgOverlay .resize-handle:active {
            background-color: var(--rick-green);
            /* Combine rotation and scale */
            transform: rotate(45deg) scale(0.95);
        }


        .imgOverlay img { display: block; width: 100%; height: 100%; object-fit: contain; pointer-events: none; }

        .floating-reset {
            position: absolute; top: 5px; right: 5px; background-color: var(--error-red); color: white;
            border: 2px solid var(--outline-black); border-radius: 50%; font-size: 1.2rem; width: 28px; height: 28px;
            box-shadow: 1px 1px 0 var(--outline-black); cursor: pointer; z-index: 999;
            display: flex; align-items: center; justify-content: center; line-height: 1;
            transition: all 0.15s ease-out;
        }
        .floating-reset:hover { transform: translateY(-1px) scale(1.05); box-shadow: 2px 2px 0 var(--outline-black); }
        .floating-reset:active { transform: translateY(1px) scale(0.95); box-shadow: 0px 0px 0 var(--outline-black); }

        /* === DISCLAIMER MODAL STYLES === */
        #disclaimerModal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(30, 30, 47, 0.85);
            display: none;
            justify-content: center; align-items: center;
            z-index: 1000;
            padding: 1rem;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #disclaimerModal.visible {
            display: flex;
            opacity: 1;
        }
        .disclaimer-content {
            background-color: var(--medium-dark);
            border: 3px solid var(--interdimensional-purple);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 500px;
            width: 90%;
            text-align: left;
            box-shadow: 4px 4px 0px var(--outline-black), 0 0 20px var(--glow-purple);
            transform: rotate(-1deg);
            position: relative;
            color: var(--off-white);
        }
         .disclaimer-content h4 {
             font-family: 'Luckiest Guy', cursive;
             font-size: 1.3rem;
             color: var(--morty-yellow);
             text-shadow: -1px -1px 0 var(--outline-black), 1px -1px 0 var(--outline-black), -1px 1px 0 var(--outline-black), 1px 1px 0 var(--outline-black), 2px 2px 0 var(--rick-green);
             margin-bottom: 1rem;
             text-align: center;
         }
        .disclaimer-content p {
            font-family: 'Roboto', sans-serif;
            margin-bottom: 1rem;
            line-height: 1.5;
        }
        .disclaimer-content p:last-of-type { margin-bottom: 1.5rem; }

        #closeDisclaimerBtn {
            position: absolute; top: 8px; right: 8px;
            background-color: var(--error-red); color: white;
            border: 2px solid var(--outline-black); border-radius: 50%;
            font-size: 1rem; width: 26px; height: 26px; font-weight: bold;
            box-shadow: 1px 1px 0 var(--outline-black);
            cursor: pointer; z-index: 1001;
            display: flex; align-items: center; justify-content: center; line-height: 1;
            transition: all 0.15s ease-out;
            padding: 0;
        }
        #closeDisclaimerBtn:hover { transform: translateY(-1px) scale(1.1); box-shadow: 2px 2px 0 var(--outline-black); }
        #closeDisclaimerBtn:active { transform: translateY(1px) scale(0.95); box-shadow: 0px 0px 0 var(--outline-black); }
        /* ==================================== */


        /* Responsive Adjustments */
        @media (max-width: 600px) {
            html { font-size: 14px; } body { padding: 0.5rem 0.2rem; }
            .main-container { padding: 0.6rem; width: 99%; margin-top: 0.2rem; border-width: 2px;}
            h3 { font-size: 1.4rem; }
            button, input[type="file"]::file-selector-button { padding: 4px 8px; font-size: 0.8rem; }
            #canvas-container { max-width: 98%; border-width: 2px;}
            .control-group { padding: 0.4rem 0.6rem; gap: 4px 6px; }
            label { font-size: 0.85rem; }
            input[type="text"], input[type="number"], select { padding: 4px 6px; font-size: 0.8rem; }
            input[type="file"] { font-size: 0.75rem;}
            :root { --handle-size: 22px; --handle-icon-size: 12px; }
            .disclaimer-content h4 { font-size: 1.2rem; }
        }
         @media (max-width: 450px) {
             .control-group { flex-direction: column; align-items: stretch; }
             .control-group > * { width: 100%; margin-bottom: 4px; }
             .control-group input[type="file"] { width: auto; max-width: 100%;}
             .text-editing-group .row { flex-direction: column; align-items: stretch;}
             input[type="text"], input[type="number"], select,
             .control-group > button { width: 100%; }
             label { margin-bottom: 1px; text-align: left; width: 100%;}
             .floating-reset { width: 26px; height: 26px; font-size: 1rem; top: 3px; right: 3px;}
             #nftStatus { font-size: 0.75rem; }
             #final-actions { flex-direction: column; gap: 4px; margin-bottom: 0.3rem;}
             #final-actions button { width: 100%; }
             .disclaimer-content { padding: 1rem; transform: rotate(0deg); }
             .disclaimer-content h4 { font-size: 1.1rem; }
             #closeDisclaimerBtn { top: 5px; right: 5px; width: 24px; height: 24px; font-size: 0.9rem; }
         }
    </style>

</head>
<body>
<div class="main-container">
    <h3>NFT Sign Generator</h3>
    <div id="controls">
        <div class="control-group">
            <label for="nftCollection">Collection:</label>
            <select id="nftCollection">
                <option value="GHN">GHN (Gooniez)</option>
                <option value="AHC">AHC (Ape Hater)</option>
            </select>
            <label for="nftTokenId">Token ID:</label>
            <input id="nftTokenId" placeholder="e.g.: 1114" type="number"/>
            <button id="loadNftBtn">Load NFT</button>
        </div>

        <p id="nftStatus">Select collection and ID, then load NFT.</p>

        <div class="control-group">
            <label for="overlayColor">Sign Color:</label>
            <input disabled id="overlayColor" type="color" value="#00ff00"/>
            <button disabled id="applyOverlayBtn">Apply Color</button>
        </div>

        <div class="control-group text-editing-group">
             <div class="row">
                 <label for="textInput">Text:</label>
                 <input disabled id="textInput" placeholder="Your text here" type="text"/>
                 <button disabled id="addTextBtn">Add Text</button>
             </div>
             <div class="row">
                 <label for="textColor">Color:</label>
                 <input disabled id="textColor" type="color" value="#ffffff"/>
                 <label for="fontSize">Size:</label>
                 <input disabled id="fontSize" max="200" min="10" type="number" value="15"/>
                 <label for="fontFamily">Font:</label>
                 <select disabled id="fontFamily">
                     <option value="'Comic Neue', cursive">Comic Neue</option>
                     <option value="'Indie Flower', cursive">Indie Flower</option>
                     <option value="'Rubik Moonrocks', cursive">Rubik Moonrocks</option>
                     <option value="'Luckiest Guy', cursive">Luckiest Guy</option>
                     <option value="Arial">Arial</option>
                     <option value="Verdana">Verdana</option>
                     <option value="Times New Roman">Times New Roman</option>
                 </select>
             </div>
             <div class="row">
                  <label for="imageUpload">Upload:</label>
                 <input type="file" id="imageUpload" accept="image/*" disabled/>
                 <button disabled id="addImageBtn">Add Image</button>
             </div>
        </div>
    </div>

    <div id="final-actions">
         <button disabled id="removeBtn">Delete Selected</button>
         <button disabled id="saveBtn">Save Image</button>
    </div>

    <div id="canvas-container">
        <button class="floating-reset" id="resetCanvas" title="Reset Canvas & Overlays">↺</button>
        <canvas height="2048" id="canvas" width="2048"></canvas>
        <!-- Overlays will be added here -->
    </div>

    <!-- === DISCLAIMER BUTTON === -->
    <div style="margin-top: 10px; width: 100%; text-align: center;">
        <button id="disclaimerBtn" style="background-color: var(--morty-yellow); color: var(--outline-black);"> Disclaimer (Read Me!) </button>
    </div>

</div> <!-- End .main-container -->

<!-- === DISCLAIMER MODAL === -->
<div id="disclaimerModal">
    <div class="disclaimer-content">
        <button id="closeDisclaimerBtn" title="Close Disclaimer">×</button>
        <h4>Comic (and Legal-ish) Warning!</h4>
        <p>
            Alright, listen up, champ: That genius (or cringey) text and that... 'creative'... image you're slapping onto your GHN or AHC using this gizmo? That's <strong>your</strong> masterpiece (or mess).
        </p>
        <p>
            I just handed you the interdimensional paintbrush and bucket. If the final result is a work of art or some scribbling that offends three galaxies, the responsibility lands squarely in <strong>your</strong> crypto wallet, not my lines of code.
        </p>
        <p>
            Got it? Good. Now get back to... uh... 'art'?
        </p>
    </div>
</div>


<script>
    // --- Global Constants ---
    const canvasWidth = 2048;
    const canvasHeight = 2048;
    const nftContracts = {
        "GHN": { address: "0xe6d48bf4ee912235398b96e16db6f310c21e82cb", name: "GHN" },
        "AHC": { address: "0x9370045ce37f381500ac7d6802513bb89871e076", name: "AHC" }
    };
    const nftAbi = ["function tokenURI(uint256 tokenId) public view returns (string)"];
    const provider = new ethers.JsonRpcProvider("https://eth.llamarpc.com");

    // --- Global State ---
    let baseImage = new Image();
    let activeElement = null;
    let textInteractionState = { isDragging: false, isRotating: false, startX: 0, startY: 0, startLeft: 0, startTop: 0, rotateCenterX: 0, rotateCenterY: 0, rotateStartAngle: 0 };
    let imageInteractionState = { isDragging: false, isRotating: false, isResizing: false, startX: 0, startY: 0, startLeft: 0, startTop: 0, centerX: 0, centerY: 0, startAngle: 0, currentRotationRad: 0, startWidth: 0, startHeight: 0, aspectRatio: 1 };

    // --- DOM Element References ---
    let canvas, ctx, container, textInput, textColor, fontSize, fontFamily, removeBtn, nftStatusEl,
        nftCollectionSelect, nftTokenIdInput, loadNftBtn, applyOverlayBtn, overlayColorInput,
        addTextBtn, saveBtn, imageUpload, addImageBtn, resetCanvasBtn,
        disclaimerBtn, disclaimerModal, closeDisclaimerBtn;

    // --- Initialization ---
    window.onload = () => {
        // Get Element References
        canvas = document.getElementById("canvas");
        ctx = canvas.getContext("2d", { willReadFrequently: true });
        container = document.getElementById("canvas-container");
        textInput = document.getElementById("textInput");
        textColor = document.getElementById("textColor");
        fontSize = document.getElementById("fontSize");
        fontFamily = document.getElementById("fontFamily");
        removeBtn = document.getElementById("removeBtn");
        nftStatusEl = document.getElementById("nftStatus");
        nftCollectionSelect = document.getElementById("nftCollection");
        nftTokenIdInput = document.getElementById("nftTokenId");
        loadNftBtn = document.getElementById("loadNftBtn");
        applyOverlayBtn = document.getElementById("applyOverlayBtn");
        overlayColorInput = document.getElementById("overlayColor");
        addTextBtn = document.getElementById("addTextBtn");
        saveBtn = document.getElementById("saveBtn");
        imageUpload = document.getElementById("imageUpload");
        addImageBtn = document.getElementById("addImageBtn");
        resetCanvasBtn = document.getElementById("resetCanvas");
        disclaimerBtn = document.getElementById("disclaimerBtn");
        disclaimerModal = document.getElementById("disclaimerModal");
        closeDisclaimerBtn = document.getElementById("closeDisclaimerBtn");

        // Initial Setup
        enableEditingControls(false);
        clearCanvas();
        setupEventListeners();
    };

    function setupEventListeners() {
        if (!loadNftBtn) { console.error("Load button not found!"); return; }

        // Event Listeners
        loadNftBtn.addEventListener('click', loadNftToCanvas);
        applyOverlayBtn.addEventListener('click', applyOverlay);
        overlayColorInput.addEventListener('input', applyOverlay);
        addTextBtn.addEventListener('click', addText);
        textInput.addEventListener("input", handleTextControlChange);
        textColor.addEventListener("input", handleTextControlChange);
        fontSize.addEventListener("input", handleTextControlChange);
        fontFamily.addEventListener("input", handleTextControlChange);
        addImageBtn.addEventListener('click', addImage);
        removeBtn.addEventListener('click', removeActiveElement);
        saveBtn.addEventListener('click', saveImage);
        resetCanvasBtn.addEventListener('click', handleReset);
        nftCollectionSelect.addEventListener("change", () => { if (baseImage.src && baseImage.complete) { applyOverlay(); } });

        // Disclaimer Modal Listeners
        if (disclaimerBtn && disclaimerModal && closeDisclaimerBtn) {
            disclaimerBtn.addEventListener('click', showComicDisclaimer);
            closeDisclaimerBtn.addEventListener('click', hideComicDisclaimer);
            disclaimerModal.addEventListener('click', (event) => {
                if (event.target === disclaimerModal) { hideComicDisclaimer(); }
            });
        } else {
            console.warn("Disclaimer modal elements not found!");
        }
    }

    // --- Event Handlers ---
     function handleTextControlChange() { if(activeElement&&activeElement.classList.contains('textOverlay')){activeElement.childNodes[0].nodeValue=textInput.value;activeElement.style.color=textColor.value;activeElement.style.fontSize=fontSize.value+"px";activeElement.style.fontFamily=fontFamily.value;} }
     function handleReset() { if(confirm("Are you sure you want to clear the canvas and all added elements? This cannot be undone.")){clearCanvasAndOverlays();if(baseImage.src&&baseImage.complete&&baseImage.naturalWidth>0){drawBaseImage();applyOverlay();enableEditingControls(true);}else{enableEditingControls(false);nftStatusEl.textContent="Select collection and ID, then load NFT.";nftStatusEl.className='';}} }

    // --- Canvas & Overlay Management ---
    function clearCanvasAndOverlays() { ctx.clearRect(0,0,canvasWidth,canvasHeight); ctx.fillStyle='#444'; ctx.fillRect(0,0,canvasWidth,canvasHeight); container.querySelectorAll('.textOverlay, .imgOverlay').forEach(el=>el.remove()); setActiveElement(null); nftStatusEl.textContent="Canvas Cleared."; nftStatusEl.className=''; }
    function clearCanvas() { ctx.clearRect(0,0,canvasWidth,canvasHeight); ctx.fillStyle='#444'; ctx.fillRect(0,0,canvasWidth,canvasHeight); }
    function enableEditingControls(isEnabled) { [overlayColorInput,applyOverlayBtn,textInput,textColor,fontSize,fontFamily,addTextBtn,saveBtn,imageUpload,addImageBtn,removeBtn].forEach(el=>{if(el)el.disabled=!isEnabled;}); updateControlState(); }
    function updateControlState() { const isElementActive=activeElement!==null; const isTextActive=isElementActive&&activeElement.classList.contains('textOverlay'); const isImageLoaded=baseImage.src!==""&&baseImage.complete&&baseImage.naturalWidth>0; if(textInput)textInput.disabled=!isTextActive||!isImageLoaded; if(textColor)textColor.disabled=!isTextActive||!isImageLoaded; if(fontSize)fontSize.disabled=!isTextActive||!isImageLoaded; if(fontFamily)fontFamily.disabled=!isTextActive||!isImageLoaded; if(overlayColorInput)overlayColorInput.disabled=!isImageLoaded; if(applyOverlayBtn)applyOverlayBtn.disabled=!isImageLoaded; if(addTextBtn)addTextBtn.disabled=!isImageLoaded; if(imageUpload)imageUpload.disabled=!isImageLoaded; if(addImageBtn)addImageBtn.disabled=!isImageLoaded; if(saveBtn)saveBtn.disabled=!isImageLoaded; if(removeBtn)removeBtn.disabled=!isElementActive||!isImageLoaded; }

    // --- NFT Loading & Drawing ---
    function getPolygonForSelectedCollection(){const selectedCollection=nftCollectionSelect.value;if(selectedCollection==="AHC"){return[{x:1415,y:316},{x:2024,y:358},{x:1958,y:1324},{x:1358,y:1286}];}else{return[{x:1403,y:196},{x:2034,y:218},{x:1968,y:1164},{x:1358,y:1126}];}}
    function resolveIpfsUrl(url) { if(url&&url.startsWith("ipfs://")){return url.replace("ipfs://","https://ipfs.io/ipfs/");}return url;}
    async function loadNftToCanvas() {
        const selectedCollection = nftCollectionSelect.value; const tokenId = nftTokenIdInput.value;
        if (!tokenId) { nftStatusEl.textContent = "Please enter a Token ID."; nftStatusEl.className = 'error'; return; }
        if (!nftContracts[selectedCollection]) { nftStatusEl.textContent = "Invalid NFT collection selected."; nftStatusEl.className = 'error'; return; }
        loadNftBtn.disabled = true; enableEditingControls(false); clearCanvasAndOverlays();
        nftStatusEl.textContent = `Loading ${nftContracts[selectedCollection].name} #${tokenId}...`; nftStatusEl.className = '';
        const contractInfo = nftContracts[selectedCollection]; const contract = new ethers.Contract(contractInfo.address, nftAbi, provider);
        try {
            let tokenURI = await contract.tokenURI(tokenId); tokenURI = resolveIpfsUrl(tokenURI);
            nftStatusEl.textContent = "Fetching metadata...";
            const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 20000);
            const response = await fetch(tokenURI, { signal: controller.signal }); clearTimeout(timeoutId);
            if (!response.ok) throw new Error(`Metadata error: ${response.status} ${response.statusText} (URL: ${tokenURI})`);
            const metadata = await response.json();
            let imageUrl = resolveIpfsUrl(metadata.image || metadata.image_url || metadata.imageUrl);
            if (!imageUrl) throw new Error("Image URL missing in metadata");
            nftStatusEl.textContent = "Loading image..."; baseImage = new Image(); baseImage.crossOrigin = "Anonymous";
            baseImage.onload = () => {
                nftStatusEl.textContent = "Drawing image..."; drawBaseImage();
                nftStatusEl.textContent = `${nftContracts[selectedCollection].name} #${tokenId} loaded successfully!`; nftStatusEl.className = 'success';
                enableEditingControls(true); loadNftBtn.disabled = false; applyOverlay();
            };
            baseImage.onerror = (err) => {
                console.error("Error loading NFT image:", err, "Attempted URL:", imageUrl); nftStatusEl.textContent = `Error loading image. Check console for details.`; nftStatusEl.className = 'error';
                loadNftBtn.disabled = false; clearCanvasAndOverlays(); ctx.fillStyle = "white"; ctx.font = "30px Arial"; ctx.textAlign = "center"; ctx.fillText("Image Load Error", canvasWidth / 2, canvasHeight / 2);
            }; baseImage.src = imageUrl;
        } catch (err) {
            console.error(`Error processing NFT ${tokenId}:`, err); let errorMsg = "Error: " + err.message;
            if (err.name === 'AbortError') { errorMsg = "Error: Metadata request timed out."; }
            else if (err.message?.includes('invalid token ID')) { errorMsg = `Error: Token ID ${tokenId} invalid or does not exist.`; }
             else if (err.message?.includes('CALL_EXCEPTION')) { errorMsg = `Error: Could not query contract. Check network/address.`; }
            nftStatusEl.textContent = errorMsg; nftStatusEl.className = 'error'; loadNftBtn.disabled = false; clearCanvasAndOverlays();
            ctx.fillStyle = "white"; ctx.font = "30px Arial"; ctx.textAlign = "center"; ctx.fillText("NFT Load Error", canvasWidth / 2, canvasHeight / 2);
        }
     }
    function drawBaseImage() { if(!baseImage.src||!baseImage.complete||baseImage.naturalWidth===0)return; const aspectRatio=baseImage.naturalWidth/baseImage.naturalHeight; let drawWidth=canvasWidth,drawHeight=canvasHeight,x=0,y=0; if(canvasWidth/canvasHeight>aspectRatio){drawHeight=canvasHeight;drawWidth=drawHeight*aspectRatio;x=(canvasWidth-drawWidth)/2;}else{drawWidth=canvasWidth;drawHeight=drawWidth/aspectRatio;y=(canvasHeight-drawHeight)/2;} ctx.clearRect(0,0,canvasWidth,canvasHeight); ctx.fillStyle="#444"; ctx.fillRect(0,0,canvasWidth,canvasHeight); try{ctx.drawImage(baseImage,x,y,drawWidth,drawHeight);}catch(e){console.error("Error drawing base image:",e); nftStatusEl.textContent="Error drawing NFT image."; nftStatusEl.className='error';} }
    function applyOverlay() { if(!baseImage.src||!baseImage.complete||baseImage.naturalWidth===0)return; drawBaseImage(); const color=overlayColorInput.value; const currentPolygon=getPolygonForSelectedCollection(); ctx.beginPath(); ctx.moveTo(currentPolygon[0].x,currentPolygon[0].y); for(let i=1;i<currentPolygon.length;i++)ctx.lineTo(currentPolygon[i].x,currentPolygon[i].y); ctx.closePath(); ctx.fillStyle=color; ctx.fill(); ctx.lineJoin="round"; ctx.lineWidth=14; ctx.strokeStyle="black"; ctx.stroke(); }

    // --- Text & Image Creation ---
    function addText() {
        if(!baseImage.src||!baseImage.complete||baseImage.naturalWidth===0){nftStatusEl.textContent="Load a valid NFT first.";nftStatusEl.className='error';return;}
        const textEl=document.createElement("div");textEl.className="textOverlay";textEl.innerText=textInput.value||"New Text";textEl.style.color=textColor.value;textEl.style.fontSize=fontSize.value+"px";textEl.style.fontFamily=fontFamily.value;textEl.style.transform=`translate(-50%, -50%) rotate(0deg)`;textEl.style.zIndex="10";const handle=document.createElement("span");handle.className="rotation-handle";handle.innerHTML='↺';textEl.appendChild(handle);const currentPolygon=getPolygonForSelectedCollection();const minX=Math.min(...currentPolygon.map(p=>p.x));const maxX=Math.max(...currentPolygon.map(p=>p.x));const minY=Math.min(...currentPolygon.map(p=>p.y));const maxY=Math.max(...currentPolygon.map(p=>p.y));const signCenterXPercent=canvasWidth?((minX+maxX)/2)/canvasWidth*100:50;const signCenterYPercent=canvasHeight?((minY+maxY)/2)/canvasHeight*100:50;const{x:initialX,y:initialY}=calculateElementPosition(signCenterXPercent,signCenterYPercent);textEl.style.left=`${initialX}px`;textEl.style.top=`${initialY}px`;textEl.addEventListener("mousedown",handleTextDragStart);textEl.addEventListener("touchstart",handleTextDragStart,{passive:true});handle.addEventListener("mousedown",handleTextRotateStart);handle.addEventListener("touchstart",handleTextRotateStart,{passive:true});container.appendChild(textEl);setActiveElement(textEl);
    }
    function addImage() {
        if(!baseImage.src||!baseImage.complete||baseImage.naturalWidth===0){nftStatusEl.textContent="Please load a valid NFT first.";nftStatusEl.className='error';return;}
        if(!imageUpload.files||imageUpload.files.length===0){nftStatusEl.textContent="Please select an image file.";nftStatusEl.className='error';return;}
        const file=imageUpload.files[0];const reader=new FileReader();
        reader.onload=function(e){const wrapper=document.createElement("div");wrapper.className="imgOverlay";wrapper.style.position="absolute";wrapper.style.width="auto";wrapper.style.height="auto";wrapper.style.transform="translate(-50%, -50%) rotate(0deg)";wrapper.style.touchAction="none";wrapper.style.zIndex="20";const img=document.createElement("img");img.src=e.target.result;
        img.onload=()=>{if(container.offsetWidth>0&&img.naturalWidth>0&&img.naturalHeight>0){const contW=container.offsetWidth;const initialWidth=Math.min(img.naturalWidth*0.60,contW*0.5,250);const aspectRatio=img.naturalWidth/img.naturalHeight;wrapper.style.width=`${initialWidth}px`;wrapper.style.height=`${initialWidth/aspectRatio}px`;}else{wrapper.style.width='100px';wrapper.style.height='auto';}};
        img.onerror=()=>{console.error("Error loading added image.");nftStatusEl.textContent="Error displaying uploaded image.";nftStatusEl.className='error';wrapper.remove();}
        wrapper.appendChild(img);const rotateHandle=document.createElement("div");rotateHandle.className="rotation-handle";rotateHandle.innerHTML='↺';wrapper.appendChild(rotateHandle);
        const resizeHandle=document.createElement("div");
        resizeHandle.className="resize-handle";
        resizeHandle.innerHTML='⤡'; // Icon remains ⤡
        wrapper.appendChild(resizeHandle);
        const currentPolygon=getPolygonForSelectedCollection();const minX=Math.min(...currentPolygon.map(p=>p.x));const maxX=Math.max(...currentPolygon.map(p=>p.x));const minY=Math.min(...currentPolygon.map(p=>p.y));const maxY=Math.max(...currentPolygon.map(p=>p.y));const signCenterXPercent=canvasWidth?((minX+maxX)/2)/canvasWidth*100:50;const signCenterYPercent=canvasHeight?((minY+maxY)/2)/canvasHeight*100:50;const{x:initialX,y:initialY}=calculateElementPosition(signCenterXPercent,signCenterYPercent);wrapper.style.left=`${initialX}px`;wrapper.style.top=`${initialY}px`;wrapper.addEventListener("mousedown",handleImageDragStart);wrapper.addEventListener("touchstart",handleImageDragStart,{passive:true});rotateHandle.addEventListener("mousedown",handleImageRotateStart);rotateHandle.addEventListener("touchstart",handleImageRotateStart,{passive:true});resizeHandle.addEventListener("mousedown",handleImageResizeStart);resizeHandle.addEventListener("touchstart",handleImageResizeStart,{passive:true});container.appendChild(wrapper);setActiveElement(wrapper);nftStatusEl.textContent="Image added.";nftStatusEl.className='success';imageUpload.value='';};
        reader.onerror=function(err){console.error("FileReader error:",err);nftStatusEl.textContent="Error reading image file.";nftStatusEl.className='error';}
        reader.readAsDataURL(file);
    }

    // --- Active Element Management & Removal ---
    function setActiveElement(el) { if(activeElement&&activeElement!==el){activeElement.classList.remove("active");activeElement.style.zIndex=activeElement.classList.contains('imgOverlay')?'20':'10';} if(el){el.classList.add("active");activeElement=el;el.style.zIndex=el.classList.contains('imgOverlay')?'101':'100';if(el.classList.contains('textOverlay')){textInput.value=el.childNodes[0].nodeValue;textColor.value=rgb2hex(el.style.color);fontSize.value=parseInt(el.style.fontSize);const currentFont=el.style.fontFamily.split(',')[0].replace(/['"]/g,"").trim();let foundFont=false;for(let option of fontFamily.options){if(option.value.includes(currentFont)){fontFamily.value=option.value;foundFont=true;break;}}if(!foundFont)fontFamily.value='Arial';}}else{activeElement=null;} updateControlState();}
    function removeActiveElement() { if(activeElement){activeElement.remove();setActiveElement(null);} }

    // --- Interaction Handlers (Corrected Resize Logic Maintained) ---
    function getEventCoordinates(event) { let x,y; if(event.touches&&event.touches.length>0){x=event.touches[0].clientX;y=event.touches[0].clientY;}else if(event.changedTouches&&event.changedTouches.length>0){x=event.changedTouches[0].clientX;y=event.changedTouches[0].clientY;}else{x=event.clientX;y=event.clientY;} return{x,y}; }
    function handleTextDragStart(event) { if(event.target.classList.contains('rotation-handle'))return;const el=event.currentTarget;setActiveElement(el);textInteractionState.isDragging=true;textInteractionState.isRotating=false;el.style.cursor='grabbing';document.body.style.cursor='grabbing';const coords=getEventCoordinates(event);const contRect=container.getBoundingClientRect();textInteractionState.startX=coords.x-contRect.left;textInteractionState.startY=coords.y-contRect.top;textInteractionState.startLeft=parseFloat(el.style.left||"0");textInteractionState.startTop=parseFloat(el.style.top||"0");document.addEventListener("mousemove",handleTextInteractionMove);document.addEventListener("mouseup",handleTextInteractionEnd);document.addEventListener("touchmove",handleTextInteractionMove,{passive:false});document.addEventListener("touchend",handleTextInteractionEnd);document.addEventListener("touchcancel",handleTextInteractionEnd);if(event.type==='mousedown')event.preventDefault();}
    function handleTextRotateStart(event) { event.stopPropagation();const el=event.currentTarget.parentElement;setActiveElement(el);textInteractionState.isRotating=true;textInteractionState.isDragging=false;document.body.style.cursor='alias';const coords=getEventCoordinates(event);const rect=el.getBoundingClientRect();textInteractionState.rotateCenterX=rect.left+rect.width/2;textInteractionState.rotateCenterY=rect.top+rect.height/2;const dx=coords.x-textInteractionState.rotateCenterX;const dy=coords.y-textInteractionState.rotateCenterY;let startAngle=Math.atan2(dy,dx);const currentRotationRad=getRotationRad(el);textInteractionState.rotateStartAngle=startAngle-currentRotationRad;document.addEventListener("mousemove",handleTextInteractionMove);document.addEventListener("mouseup",handleTextInteractionEnd);document.addEventListener("touchmove",handleTextInteractionMove,{passive:false});document.addEventListener("touchend",handleTextInteractionEnd);document.addEventListener("touchcancel",handleTextInteractionEnd);if(event.type==='mousedown')event.preventDefault();}
    function handleTextInteractionMove(event) { if(!activeElement||!activeElement.classList.contains('textOverlay')||(!textInteractionState.isDragging&&!textInteractionState.isRotating))return; if(event.type==='touchmove')event.preventDefault(); const coords=getEventCoordinates(event); const contRect=container.getBoundingClientRect(); if(textInteractionState.isDragging){const currentX=coords.x-contRect.left; const currentY=coords.y-contRect.top; let potentialNewLeft=textInteractionState.startLeft+(currentX-textInteractionState.startX); let potentialNewTop=textInteractionState.startTop+(currentY-textInteractionState.startY); const{canvasX,canvasY}=getCanvasCoordsFromContainerPoint(potentialNewLeft,potentialNewTop); if(pointInPolygon({x:canvasX,y:canvasY},getPolygonForSelectedCollection())){activeElement.style.left=`${potentialNewLeft}px`; activeElement.style.top=`${potentialNewTop}px`;}}else if(textInteractionState.isRotating){const dx=coords.x-textInteractionState.rotateCenterX; const dy=coords.y-textInteractionState.rotateCenterY; let angle=Math.atan2(dy,dx); let rotationRad=angle-textInteractionState.rotateStartAngle; let rotationDeg=rotationRad*(180/Math.PI); activeElement.style.transform=`translate(-50%, -50%) rotate(${rotationDeg}deg)`;}}
    function handleTextInteractionEnd(event) { if(activeElement&&activeElement.classList.contains('textOverlay')){activeElement.style.cursor='grab';} document.body.style.cursor='default'; textInteractionState.isDragging=false; textInteractionState.isRotating=false; document.removeEventListener("mousemove",handleTextInteractionMove); document.removeEventListener("mouseup",handleTextInteractionEnd); document.removeEventListener("touchmove",handleTextInteractionMove); document.removeEventListener("touchend",handleTextInteractionEnd); document.removeEventListener("touchcancel",handleTextInteractionEnd); }
    function handleImageDragStart(event) { if(event.target.classList.contains('rotation-handle')||event.target.classList.contains('resize-handle'))return;const el=event.currentTarget;setActiveElement(el);imageInteractionState.isDragging=true;imageInteractionState.isRotating=false;imageInteractionState.isResizing=false;el.style.cursor='grabbing';document.body.style.cursor='grabbing';const coords=getEventCoordinates(event);const contRect=container.getBoundingClientRect();imageInteractionState.startX=coords.x-contRect.left;imageInteractionState.startY=coords.y-contRect.top;imageInteractionState.startLeft=parseFloat(el.style.left||"0");imageInteractionState.startTop=parseFloat(el.style.top||"0");document.addEventListener("mousemove",handleImageInteractionMove);document.addEventListener("mouseup",handleImageInteractionEnd);document.addEventListener("touchmove",handleImageInteractionMove,{passive:false});document.addEventListener("touchend",handleImageInteractionEnd);document.addEventListener("touchcancel",handleImageInteractionEnd);if(event.type==='mousedown')event.preventDefault();}
    function handleImageRotateStart(event) { event.stopPropagation();const el=event.currentTarget.parentElement;setActiveElement(el);imageInteractionState.isRotating=true;imageInteractionState.isDragging=false;imageInteractionState.isResizing=false;document.body.style.cursor='alias';const coords=getEventCoordinates(event);const rect=el.getBoundingClientRect();imageInteractionState.centerX=rect.left+rect.width/2;imageInteractionState.centerY=rect.top+rect.height/2;const dx=coords.x-imageInteractionState.centerX;const dy=coords.y-imageInteractionState.centerY;let startAngle=Math.atan2(dy,dx);imageInteractionState.currentRotationRad=getRotationRad(el);imageInteractionState.startAngle=startAngle-imageInteractionState.currentRotationRad;document.addEventListener("mousemove",handleImageInteractionMove);document.addEventListener("mouseup",handleImageInteractionEnd);document.addEventListener("touchmove",handleImageInteractionMove,{passive:false});document.addEventListener("touchend",handleImageInteractionEnd);document.addEventListener("touchcancel",handleImageInteractionEnd);if(event.type==='mousedown')event.preventDefault();}
    function handleImageResizeStart(event) { event.stopPropagation();const el=event.currentTarget.parentElement;setActiveElement(el);imageInteractionState.isResizing=true;imageInteractionState.isRotating=false;imageInteractionState.isDragging=false;document.body.style.cursor='nesw-resize'; const coords=getEventCoordinates(event);imageInteractionState.startX=coords.x;imageInteractionState.startY=coords.y;imageInteractionState.startWidth=el.offsetWidth;imageInteractionState.startHeight=el.offsetHeight;imageInteractionState.aspectRatio=imageInteractionState.startHeight>0?imageInteractionState.startWidth/imageInteractionState.startHeight:1;imageInteractionState.currentRotationRad=getRotationRad(el);const rect=el.getBoundingClientRect();imageInteractionState.centerX=rect.left+rect.width/2;imageInteractionState.centerY=rect.top+rect.height/2;document.addEventListener("mousemove",handleImageInteractionMove);document.addEventListener("mouseup",handleImageInteractionEnd);document.addEventListener("touchmove",handleImageInteractionMove,{passive:false});document.addEventListener("touchend",handleImageInteractionEnd);document.addEventListener("touchcancel",handleImageInteractionEnd);if(event.type==='mousedown')event.preventDefault();}
    function handleImageInteractionMove(event) {
        if(!activeElement||!activeElement.classList.contains('imgOverlay')||(!imageInteractionState.isDragging&&!imageInteractionState.isRotating&&!imageInteractionState.isResizing))return;
        if(event.type==='touchmove')event.preventDefault();
        const coords=getEventCoordinates(event);
        const contRect=container.getBoundingClientRect();

        if(imageInteractionState.isDragging){
            const currentX=coords.x-contRect.left;
            const currentY=coords.y-contRect.top;
            let potentialNewLeft=imageInteractionState.startLeft+(currentX-imageInteractionState.startX);
            let potentialNewTop=imageInteractionState.startTop+(currentY-imageInteractionState.startY);
            const{canvasX,canvasY}=getCanvasCoordsFromContainerPoint(potentialNewLeft,potentialNewTop);
            if(pointInPolygon({x:canvasX,y:canvasY},getPolygonForSelectedCollection())){
                activeElement.style.left=`${potentialNewLeft}px`;
                activeElement.style.top=`${potentialNewTop}px`;
            }
        } else if(imageInteractionState.isRotating){
            const dx=coords.x-imageInteractionState.centerX;
            const dy=coords.y-imageInteractionState.centerY;
            let angle=Math.atan2(dy,dx);
            let rotationRad=angle-imageInteractionState.startAngle;
            let rotationDeg=rotationRad*(180/Math.PI);
            activeElement.style.transform=`translate(-50%, -50%) rotate(${rotationDeg}deg)`;
        } else if(imageInteractionState.isResizing){
            const dx=coords.x-imageInteractionState.startX;
            const dy=coords.y-imageInteractionState.startY;
            const rotation=imageInteractionState.currentRotationRad;
            const cosR=Math.cos(rotation);
            const sinR=Math.sin(rotation);
            const rotatedDx = dx * cosR + dy * sinR;
            const rotatedDy = -dx * sinR + dy * cosR;

            // Corrected logic for bottom-left handle
            const diagonalDelta = (-rotatedDx + rotatedDy) / 2;

            let newWidth = imageInteractionState.startWidth + diagonalDelta;
            newWidth = Math.max(30, newWidth);
            let newHeight = imageInteractionState.aspectRatio>0?newWidth/imageInteractionState.aspectRatio:newWidth;
            activeElement.style.width=`${newWidth}px`;
            activeElement.style.height=`${newHeight}px`;
        }
    }
    function handleImageInteractionEnd(event) { if(activeElement&&activeElement.classList.contains('imgOverlay')){activeElement.style.cursor='grab';} document.body.style.cursor='default'; imageInteractionState.isDragging=false; imageInteractionState.isRotating=false; imageInteractionState.isResizing=false; document.removeEventListener("mousemove",handleImageInteractionMove); document.removeEventListener("mouseup",handleImageInteractionEnd); document.removeEventListener("touchmove",handleImageInteractionMove); document.removeEventListener("touchend",handleImageInteractionEnd); document.removeEventListener("touchcancel",handleImageInteractionEnd); }

    // --- Utility Functions ---
    function calculateElementPosition(percentX,percentY){const contRect=container.getBoundingClientRect();if(!contRect||contRect.width===0||contRect.height===0)return{x:0,y:0};const scaleX=contRect.width/canvasWidth;const scaleY=contRect.height/canvasHeight;const targetCanvasX=canvasWidth*(percentX/100);const targetCanvasY=canvasHeight*(percentY/100);return{x:targetCanvasX*scaleX,y:targetCanvasY*scaleY};}
    function getCanvasCoordsFromContainerPoint(containerX,containerY){const contRect=container.getBoundingClientRect();if(!contRect||contRect.width===0||contRect.height===0)return{canvasX:0,canvasY:0};const scaleX=contRect.width/canvasWidth;const scaleY=contRect.height/canvasHeight;return{canvasX:containerX/scaleX,canvasY:containerY/scaleY};}
    function pointInPolygon(point,vs){const x=point.x,y=point.y;let inside=false;for(let i=0,j=vs.length-1;i<vs.length;j=i++){const xi=vs[i].x,yi=vs[i].y;const xj=vs[j].x,yj=vs[j].y;const intersect=((yi>y)!==(yj>y))&&(x<(xj-xi)*(y-yi)/(yj-yi)+xi);if(intersect)inside=!inside;}return inside;}
    function rgb2hex(rgb){if(!rgb)return'#ffffff';if(rgb.startsWith('#'))return rgb;const rgbMatch=rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);if(rgbMatch){return"#"+rgbMatch.slice(1).map(x=>parseInt(x).toString(16).padStart(2,'0')).join('');}return rgb;}
    function getRotationRad(element){if(!element||!element.style)return 0;const transform=element.style.transform;const rotateMatch=transform.match(/rotate\((-?\d+(\.\d+)?)deg\)/);const rotationDeg=rotateMatch?parseFloat(rotateMatch[1]):0;return rotationDeg*(Math.PI/180);}

    // --- DISCLAIMER Functions ---
    function showComicDisclaimer() { if (disclaimerModal) { disclaimerModal.classList.add('visible'); } }
    function hideComicDisclaimer() { if (disclaimerModal) { disclaimerModal.classList.remove('visible'); } }

    // --- Save Functionality ---
    function saveImage() {
        if(!baseImage.src||!baseImage.complete||baseImage.naturalWidth===0){alert("Load a valid NFT first!");nftStatusEl.className='error';return;}
        nftStatusEl.textContent="Generating final image...";nftStatusEl.className='';

        drawBaseImage();
        applyOverlay();

        const canvasRect = canvas.getBoundingClientRect();
        if(!canvasRect || canvasRect.width === 0 || canvasRect.height === 0) {
             alert("Error: Could not get canvas dimensions for saving.");
             nftStatusEl.className='error';
             nftStatusEl.textContent="Save Error: Canvas rect invalid.";
             return;
        }

        const scaleX = canvasRect.width / canvasWidth;
        const scaleY = canvasRect.height / canvasHeight;

        const allOverlays=Array.from(container.querySelectorAll(".textOverlay, .imgOverlay"));
        allOverlays.sort((a,b)=>(parseInt(window.getComputedStyle(a).zIndex)||0)-(parseInt(window.getComputedStyle(b).zIndex)||0));

        allOverlays.forEach(el=>{
            const elRect = el.getBoundingClientRect();
            const rotationRad = getRotationRad(el);

            const elCenterX_viewport = elRect.left + elRect.width / 2;
            const elCenterY_viewport = elRect.top + elRect.height / 2;
            const relativeCenterX = elCenterX_viewport - canvasRect.left;
            const relativeCenterY = elCenterY_viewport - canvasRect.top;
            const rawCanvasX = (relativeCenterX / canvasRect.width) * canvasWidth;
            const rawCanvasY = (relativeCenterY / canvasRect.height) * canvasHeight;
            const canvasX = Math.round(rawCanvasX);
            const canvasY = Math.round(rawCanvasY);

            ctx.save();
            ctx.translate(canvasX, canvasY);
            ctx.rotate(rotationRad);

            if(el.classList.contains('textOverlay')){
                const text=el.childNodes[0].nodeValue; const color=el.style.color; const size=parseInt(el.style.fontSize); const font=el.style.fontFamily;
                const canvasFontSize = Math.round(size / scaleY);
                ctx.font=`${canvasFontSize}px ${font}`; ctx.fillStyle=color; ctx.textAlign="center"; ctx.textBaseline="middle";
                ctx.fillText(text, 0, 0);
            } else if(el.classList.contains('imgOverlay')){
                const imgElement=el.querySelector('img');
                if(imgElement&&imgElement.complete&&imgElement.naturalWidth>0){
                     const domWidth = el.offsetWidth;
                     const canvasDrawWidth = Math.round(domWidth / scaleX);
                     const naturalAspectRatio = imgElement.naturalWidth > 0 ? imgElement.naturalHeight / imgElement.naturalWidth : 1;
                     const canvasDrawHeight = Math.round(canvasDrawWidth * naturalAspectRatio);
                     if (canvasDrawWidth > 0 && canvasDrawHeight > 0) {
                        ctx.drawImage(imgElement, -canvasDrawWidth / 2, -canvasDrawHeight / 2, canvasDrawWidth, canvasDrawHeight);
                     }
                } else {
                    console.warn("Skipping unloaded/invalid image overlay during save:", imgElement?.src);
                }
            }
            ctx.restore();
        });

        // Generate and download the image
        try{
            const dataURL=canvas.toDataURL("image/png");
            const link=document.createElement("a");
            const filename=`signed-${nftCollectionSelect.value}-${nftTokenIdInput.value}.png`;
            link.download=filename; link.href=dataURL;
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
            nftStatusEl.textContent=`Image saved as ${filename}!`; nftStatusEl.className='success';
        }catch(e){
            console.error("Error saving image:",e);
            if(e.name==="SecurityError"){
                alert("Save Error: Cannot save canvas due to cross-origin image security restrictions. Ensure NFT images allow cross-origin use (CORS).");
                nftStatusEl.textContent="Save Error: Cross-origin issue."; nftStatusEl.className='error';
            } else {
                alert("An error occurred while saving the image.");
                nftStatusEl.textContent="Save Error."; nftStatusEl.className='error';
            }
        }
    }

</script>
</body>
</html>