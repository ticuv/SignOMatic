<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>NFT Sign Generator (Ticuv Style Enhanced)</title> <script src="https://cdn.jsdelivr.net/npm/ethers@6.6.2/dist/ethers.umd.min.js"></script>

    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Roboto:wght@400;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&family=Indie+Flower&family=Rubik+Moonrocks&display=swap" rel="stylesheet">


    <style>
        /* ======================================== */
        /* CSS Styles (Ticuv Style - Enhanced)    */
        /* ======================================== */

        :root {
            /* Color Palette (Seems identical to signs.ticuv.art) */
            --rick-green: #97ce4c; --morty-yellow: #f0e14a; --portal-blue: #00b0c8;
            --interdimensional-purple: #aa6bd1; --slime-green: #c3ff5d; --dark-matter: #1e1e2f;
            --medium-dark: #2a2a3a; --light-bg: #3a3a4a; --input-bg: #3b3b50;
            --off-white: #f0f0e0; --error-red: #ff4d4d; --outline-black: #1a1a1a;
            --glow-green: rgba(151, 206, 76, 0.7); --glow-blue: rgba(0, 176, 200, 0.7);
            --disabled-text: #888; --disabled-border: #555; --disabled-shadow: #444;
            --handle-active-bg: yellow; --handle-image-active-bg: cyan; --handle-resize-active-bg: lime;

            /* UI adjustments (Based on your compact version, seems appropriate) */
            --control-padding: 0.5rem 0.7rem;
            --control-gap: 5px 8px;
            --button-padding: 6px 12px; /* Slightly adjusted padding */
            --button-font-size: 0.85rem;
            --input-padding: 5px 8px;
            --input-font-size: 0.85rem;
            --label-font-size: 0.9rem;
            --handle-size: 26px;
            --handle-icon-size: 16px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { font-size: 15px; scroll-behavior: smooth; }

        body {
            font-family: 'Roboto', sans-serif; background-color: var(--dark-matter); color: var(--off-white);
            line-height: 1.4; display: flex; justify-content: center; align-items: flex-start;
            min-height: 100vh; padding: 0.5rem 0.3rem;
            /* Background matches signs.ticuv.art very closely */
            background-image: repeating-linear-gradient(45deg, rgba(42, 42, 58, 0.8) 0, rgba(42, 42, 58, 0.8) 20px, transparent 20px, transparent 40px),
                              repeating-linear-gradient(-45deg, rgba(42, 42, 58, 0.8) 0, rgba(42, 42, 58, 0.8) 20px, transparent 20px, transparent 40px);
            background-size: 56px 56px; overflow-x: hidden;
        }

        .main-container {
            background-color: var(--medium-dark); border: 3px solid var(--interdimensional-purple);
            border-radius: 12px; padding: 0.8rem;
            max-width: 650px;
            width: 98%; text-align: center; box-shadow: 4px 4px 0px var(--outline-black), 0 0 15px rgba(0,0,0,0.4);
            margin: 0.4rem auto 0 auto;
            transform: rotate(-0.5deg); transition: transform 0.3s ease-out;
            display: flex; flex-direction: column; align-items: center;
        }
        .main-container:hover { transform: rotate(0.1deg) scale(1.005); } /* Subtle hover effect matches */

        h3 {
            font-family: 'Luckiest Guy', cursive; font-size: 1.6rem;
            color: var(--rick-green);
            /* Text shadow matches */
            text-shadow: -1px -1px 0 var(--outline-black), 1px -1px 0 var(--outline-black), -1px 1px 0 var(--outline-black), 1px 1px 0 var(--outline-black), 2px 2px 0 var(--interdimensional-purple);
            margin-bottom: 0.6rem;
            letter-spacing: 0.5px;
        }

        /* Controls Section Styling (Matches) */
        #controls {
            width: 100%; background: none; padding: 0; border-radius: 0;
            margin-bottom: 0.5rem;
            display: flex; flex-direction: column; gap: 0.6rem;
            align-items: stretch;
        }

        .control-group {
            border: 2px dashed var(--morty-yellow); padding: var(--control-padding);
            border-radius: 10px; background-color: rgba(0,0,0, 0.2); display: flex;
            flex-wrap: wrap; justify-content: center; align-items: center; gap: var(--control-gap);
        }
         .text-editing-group { flex-direction: column; align-items: stretch; }
         .text-editing-group .row { display: flex; flex-wrap: wrap; gap: var(--control-gap); align-items: center; justify-content: flex-start; }
         .text-editing-group .row:not(:last-child){ margin-bottom: 5px; }
         .text-editing-group .row label { flex-shrink: 0; margin-right: 5px;}
         .text-editing-group .row .spacer { flex-grow: 1; min-width: 5px; }
         .text-editing-group input[type="text"] { flex-grow: 1; min-width: 120px; }
         .text-editing-group select { min-width: 100px; }

        /* Label Styles (Matches) */
        label {
            font-family: 'Luckiest Guy', cursive; color: var(--portal-blue);
            font-size: var(--label-font-size); margin-right: 3px;
            text-shadow: 1px 1px 0 var(--outline-black); white-space: nowrap;
        }

        /* Input & Select Styles (Matches closely) */
        input[type="text"], input[type="number"], select {
            font-family: 'Roboto', sans-serif; border: 2px solid var(--outline-black);
            border-radius: 6px; padding: var(--input-padding); font-size: var(--input-font-size);
            background-color: var(--input-bg); color: var(--morty-yellow);
            box-shadow: inset 1px 1px 0px rgba(0,0,0,0.4); transition: all 0.2s ease;
        }
        input[type="number"] { max-width: 65px; text-align: center; flex-grow: 0; flex-shrink: 0; }
        select {
            appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23f0e14a'%3E%3Cpolygon points='8,12 4,6 12,6' stroke='%231a1a1a' stroke-width='1.5'/%3E%3C/svg%3E");
            background-repeat: no-repeat; background-position: right 8px center; background-size: 16px 16px;
            padding-right: 30px; cursor: pointer; flex-grow: 1; min-width: 100px;
        }
        input:focus, select:focus {
            outline: none; /* Remove default outline */
            box-shadow: inset 1px 1px 0px rgba(0,0,0,0.4), 0 0 0 2px var(--portal-blue); /* Focus ring like target */
        }
        /* Color Input Styling */
        input[type="color"] {
            width: 40px; height: 30px; /* Adjust size if needed */
            padding: 2px; border: 2px solid var(--outline-black); border-radius: 6px;
            background-color: var(--input-bg); cursor: pointer;
            transition: transform 0.15s ease-out; vertical-align: middle;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 3px; }
        input[type="color"]::-moz-color-swatch { border: none; border-radius: 3px; }
        input[type="color"]:hover:not(:disabled) { transform: scale(1.05); }

        /* File Input Styling (Enhanced to look like buttons) */
        input[type="file"] {
            font-family: 'Roboto', sans-serif;
            font-size: 0.75rem; /* Match other compact elements */
            color: var(--off-white); /* Text color for "No file chosen" */
            max-width: 200px; /* Limit width */
        }
        input[type="file"]::file-selector-button {
             /* --- Style like other buttons --- */
            font-family: 'Luckiest Guy', cursive;
            font-size: var(--button-font-size);
            padding: var(--button-padding);
            border-radius: 8px;
            border: 2px solid var(--outline-black);
            background-color: var(--interdimensional-purple); /* Choose a default color */
            color: var(--off-white);
            text-shadow: 1px 1px 0 var(--outline-black);
            box-shadow: 2px 2px 0px var(--outline-black);
            cursor: pointer;
            transition: all 0.15s ease-out;
            margin-right: 10px; /* Space between button and text */
        }
        input[type="file"]::file-selector-button:hover:not(:disabled) {
            /* --- Apply standard button hover --- */
            transform: translateY(-1px) scale(1.02);
            box-shadow: 3px 3px 0px var(--outline-black);
        }
         input[type="file"]::file-selector-button:active:not(:disabled) {
             /* --- Apply standard button active --- */
             transform: translateY(1px) scale(0.98);
             box-shadow: 1px 1px 0px var(--outline-black);
         }


        /* === Button Styles (Enhanced Hover/Active Effects) === */
        button {
            font-family: 'Luckiest Guy', cursive;
            font-size: var(--button-font-size);
            padding: var(--button-padding);
            border-radius: 8px;
            border: 2px solid var(--outline-black);
            text-shadow: 1px 1px 0 var(--outline-black);
            box-shadow: 2px 2px 0px var(--outline-black); /* Base shadow */
            cursor: pointer;
            transition: all 0.15s ease-out; /* Transition for effects */
            user-select: none;
            text-align: center;
            vertical-align: middle;
            white-space: nowrap;
        }
        /* Specific Button Colors (Matches) */
        #loadNftBtn { background-color: var(--portal-blue); color: var(--off-white); }
        #applyOverlayBtn { background-color: var(--rick-green); color: var(--outline-black); }
        #addTextBtn, #addImageBtn { background-color: var(--morty-yellow); color: var(--outline-black); }
        #removeBtn { background-color: var(--error-red); color: var(--off-white); }
        #saveBtn { background-color: var(--slime-green); color: var(--outline-black); }

        /* --- Hover Effect (Matches signs.ticuv.art) --- */
        button:hover:not(:disabled) {
            transform: translateY(-1px) scale(1.02); /* Slight lift and scale */
            box-shadow: 3px 3px 0px var(--outline-black); /* Increased shadow */
        }
        /* --- Active Effect (Matches signs.ticuv.art) --- */
        button:active:not(:disabled) {
            transform: translateY(1px) scale(0.98); /* Press down and scale */
            box-shadow: 1px 1px 0px var(--outline-black); /* Reduced shadow */
        }

        /* Disabled States (Matches) */
        input:disabled, select:disabled, button:disabled,
        input[type="file"]:disabled::file-selector-button {
            background-color: var(--light-bg);
            color: var(--disabled-text);
            border-color: var(--disabled-border);
            box-shadow: 1px 1px 0px var(--disabled-shadow);
            cursor: not-allowed;
            text-shadow: none;
            transform: none; /* Disable transforms */
        }
        select:disabled {
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23888888'%3E%3Cpolygon points='8,12 4,6 12,6' stroke='%23555555' stroke-width='1.5'/%3E%3C/svg%3E"); /* Dimmed arrow */
        }
        input[type="color"]:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        input[type="file"]:disabled { color: var(--disabled-text); }


        #nftStatus {
            width: 100%; text-align: center; font-style: italic; min-height: 1.4em;
            margin: 4px 0 4px 0; font-size: 0.85rem;
            color: var(--morty-yellow); text-shadow: 1px 1px 0 var(--outline-black);
            padding: 0 5px; word-wrap: break-word;
        }
        #nftStatus.error { color: var(--error-red); }
        #nftStatus.success { color: var(--slime-green); }

        /* Action Buttons Area (Above Canvas) */
        #final-actions {
            display: flex; justify-content: center; gap: 10px;
            width: 100%; margin-bottom: 0.4rem;
        }

        /* Canvas Container Styling (Matches) */
        #canvas-container {
            width: 100%; max-width: 500px;
            aspect-ratio: 1 / 1; margin: 0 auto; position: relative;
            cursor: default; touch-action: none; overflow: hidden;
            border: 3px solid var(--portal-blue);
            background-color: #000; border-radius: 8px;
            box-shadow: 0 0 12px var(--glow-blue), inset 0 0 8px rgba(0,0,0,0.7);
        }
        canvas { display: block; width: 100%; height: 100%; object-fit: contain; background-color: var(--medium-dark); border: none; border-radius: 6px; }

        /* Text & Image Overlay Styles (Matches closely) */
        .textOverlay, .imgOverlay { position: absolute; transform-origin: center center; user-select: none; touch-action: none; cursor: grab; transform: translate(-50%, -50%) rotate(0deg); padding: 3px; box-sizing: border-box; }
        .textOverlay { white-space: nowrap; font-weight: bold; z-index: 10; }
        .imgOverlay { z-index: 20; border: 1px dashed transparent; }
        .textOverlay.active { outline: 2px dashed var(--handle-active-bg); z-index: 100; cursor: grabbing; }
        .imgOverlay.active { outline: 2px dashed var(--handle-image-active-bg); z-index: 101; cursor: grabbing; }

        /* Handle Styles (Matches) */
        .textOverlay .rotation-handle, .imgOverlay .rotation-handle, .imgOverlay .resize-handle { position: absolute; width: var(--handle-size); height: var(--handle-size); border-radius: 50%; border: 2px solid var(--outline-black); display: none; pointer-events: auto; touch-action: none; font-family: sans-serif; font-size: var(--handle-icon-size); line-height: calc(var(--handle-size) - 4px); text-align: center; box-shadow: 1px 1px 0 var(--outline-black); background-color: transparent; color: var(--outline-black); }
        .textOverlay.active .rotation-handle, .imgOverlay.active .rotation-handle, .imgOverlay.active .resize-handle { display: block; }
        .textOverlay .rotation-handle, .imgOverlay .rotation-handle { bottom: calc(-1 * var(--handle-size) - 4px); left: 50%; transform: translateX(-50%); cursor: alias; color: var(--handle-active-bg); text-shadow: 1px 1px 1px var(--outline-black); }
        .imgOverlay .rotation-handle { color: var(--handle-image-active-bg); }
        .imgOverlay .resize-handle { right: calc(-0.5 * var(--handle-size) - 2px); bottom: calc(-0.5 * var(--handle-size) - 2px); cursor: nwse-resize; color: var(--handle-resize-active-bg); font-size: calc(var(--handle-icon-size) * 0.9); text-shadow: 1px 1px 1px var(--outline-black); }
        .imgOverlay img { display: block; width: 100%; height: 100%; object-fit: contain; pointer-events: none; }

        /* Reset Button (Applying standard button effects) */
        .floating-reset {
            position: absolute; top: 5px; right: 5px;
            background-color: var(--error-red); color: white;
            border: 2px solid var(--outline-black); border-radius: 50%;
            font-size: 1.2rem; width: 28px; height: 28px;
            box-shadow: 1px 1px 0 var(--outline-black); /* Base shadow slightly smaller */
            cursor: pointer; z-index: 999;
            display: flex; align-items: center; justify-content: center; line-height: 1;
            transition: all 0.15s ease-out; /* Added transition */
        }
        .floating-reset:hover {
            transform: translateY(-1px) scale(1.05); /* Slightly different pop */
            box-shadow: 2px 2px 0 var(--outline-black);
        }
        .floating-reset:active {
            transform: translateY(1px) scale(0.95);
            box-shadow: 0px 0px 0 var(--outline-black); /* No shadow when pressed */
        }

        /* Responsive Adjustments (Kept from original, seem appropriate) */
        @media (max-width: 600px) {
            html { font-size: 14px; }
            body { padding: 0.5rem 0.2rem; }
            .main-container { padding: 0.6rem; width: 99%; margin-top: 0.2rem; border-width: 2px;}
            h3 { font-size: 1.4rem; }
            button, input[type="file"]::file-selector-button { padding: 4px 8px; font-size: 0.8rem; } /* Adjusted file button too */
            #canvas-container { max-width: 98%; border-width: 2px;}
            .control-group { padding: 0.4rem 0.6rem; gap: 4px 6px; }
            label { font-size: 0.85rem; }
            input[type="text"], input[type="number"], select { padding: 4px 6px; font-size: 0.8rem; }
            input[type="file"] { font-size: 0.75rem;} /* Keep file text small */
            :root { --handle-size: 22px; --handle-icon-size: 12px; }
        }
         @media (max-width: 450px) {
             .control-group { flex-direction: column; align-items: stretch; }
             .control-group > * { width: 100%; margin-bottom: 4px; }
             /* Ensure file input button doesn't take full width unless needed */
             .control-group input[type="file"] { width: auto; max-width: 100%;}
             .text-editing-group .row { flex-direction: column; align-items: stretch;}
             input[type="text"], input[type="number"], select,
             .control-group > button { width: 100%; } /* Buttons in groups take full width */
             label { margin-bottom: 1px; text-align: left; width: 100%;}
             .floating-reset { width: 26px; height: 26px; font-size: 1rem; top: 3px; right: 3px;}
             #nftStatus { font-size: 0.75rem; }
             #final-actions { flex-direction: column; gap: 4px; margin-bottom: 0.3rem;}
             #final-actions button { width: 100%; } /* Final action buttons take full width */
         }

    </style>

</head>
<body>
<div class="main-container">
    <h3>NFT Sign Generator</h3>
    <div id="controls">
        <div class="control-group">
            <label for="nftCollection">Collection:</label>
            <select id="nftCollection">
                <option value="GHN">GHN (Gooniez)</option>
                <option value="AHC">AHC (Ape Hater)</option>
            </select>
            <label for="nftTokenId">Token ID:</label>
            <input id="nftTokenId" placeholder="e.g.: 1114" type="number"/>
            <button id="loadNftBtn">Load NFT</button> </div>

        <p id="nftStatus">Select collection and ID, then load NFT.</p>

        <div class="control-group">
            <label for="overlayColor">Sign Color:</label>
            <input disabled id="overlayColor" type="color" value="#00ff00"/>
            <button disabled id="applyOverlayBtn">Apply Color</button> </div>

        <div class="control-group text-editing-group">
             <div class="row">
                 <label for="textInput">Text:</label>
                 <input disabled id="textInput" placeholder="Your text here" type="text"/>
                 <button disabled id="addTextBtn">Add Text</button> </div>
             <div class="row">
                 <label for="textColor">Color:</label>
                 <input disabled id="textColor" type="color" value="#ffffff"/>
                 <label for="fontSize">Size:</label>
                 <input disabled id="fontSize" max="200" min="10" type="number" value="15"/>
                 <label for="fontFamily">Font:</label>
                 <select disabled id="fontFamily">
                     <option value="'Comic Neue', cursive">Comic Neue</option>
                     <option value="'Indie Flower', cursive">Indie Flower</option>
                     <option value="'Rubik Moonrocks', cursive">Rubik Moonrocks</option>
                     <option value="'Luckiest Guy', cursive">Luckiest Guy</option>
                     <option value="Arial">Arial</option>
                     <option value="Verdana">Verdana</option>
                     <option value="Times New Roman">Times New Roman</option>
                 </select>
             </div>
             <div class="row">
                  <label for="imageUpload">Upload:</label>
                 <input type="file" id="imageUpload" accept="image/*" disabled/>
                 <button disabled id="addImageBtn">Add Image</button> </div>
        </div>
    </div> <div id="final-actions">
         <button disabled id="removeBtn">Delete Selected</button> <button disabled id="saveBtn">Save Image</button> </div>

    <div id="canvas-container">
        <button class="floating-reset" id="resetCanvas" title="Reset Canvas & Overlays">↺</button> <canvas height="2048" id="canvas" width="2048"></canvas>
        </div>
</div> <script>
    // --- Global Constants ---
    const canvasWidth = 2048;
    const canvasHeight = 2048;
    const nftContracts = {
        "GHN": { address: "0xe6d48bf4ee912235398b96e16db6f310c21e82cb", name: "GHN" },
        "AHC": { address: "0x9370045ce37f381500ac7d6802513bb89871e076", name: "AHC" }
    };
    const nftAbi = ["function tokenURI(uint256 tokenId) public view returns (string)"];
    const provider = new ethers.JsonRpcProvider("https://eth.llamarpc.com");

    // --- Global State ---
    let baseImage = new Image();
    let activeElement = null;
    let textInteractionState = { isDragging: false, isRotating: false, startX: 0, startY: 0, startLeft: 0, startTop: 0, rotateCenterX: 0, rotateCenterY: 0, rotateStartAngle: 0 };
    let imageInteractionState = { isDragging: false, isRotating: false, isResizing: false, startX: 0, startY: 0, startLeft: 0, startTop: 0, centerX: 0, centerY: 0, startAngle: 0, currentRotationRad: 0, startWidth: 0, startHeight: 0, aspectRatio: 1 };

    // --- DOM Element References (declared globally for access) ---
    let canvas, ctx, container, textInput, textColor, fontSize, fontFamily, removeBtn, nftStatusEl,
        nftCollectionSelect, nftTokenIdInput, loadNftBtn, applyOverlayBtn, overlayColorInput,
        addTextBtn, saveBtn, imageUpload, addImageBtn, resetCanvasBtn;

    // --- Initialization ---
    window.onload = () => {
        // Get Element References **after** DOM is loaded
        canvas = document.getElementById("canvas");
        ctx = canvas.getContext("2d", { willReadFrequently: true }); // Optimization hint for saving
        container = document.getElementById("canvas-container");
        textInput = document.getElementById("textInput");
        textColor = document.getElementById("textColor");
        fontSize = document.getElementById("fontSize");
        fontFamily = document.getElementById("fontFamily");
        removeBtn = document.getElementById("removeBtn");
        nftStatusEl = document.getElementById("nftStatus");
        nftCollectionSelect = document.getElementById("nftCollection");
        nftTokenIdInput = document.getElementById("nftTokenId");
        loadNftBtn = document.getElementById("loadNftBtn");
        applyOverlayBtn = document.getElementById("applyOverlayBtn");
        overlayColorInput = document.getElementById("overlayColor");
        addTextBtn = document.getElementById("addTextBtn");
        saveBtn = document.getElementById("saveBtn");
        imageUpload = document.getElementById("imageUpload");
        addImageBtn = document.getElementById("addImageBtn");
        resetCanvasBtn = document.getElementById("resetCanvas");

        // Initial Setup
        enableEditingControls(false);
        clearCanvas();
        setupEventListeners(); // Attach listeners now that elements are referenced
    };

    function setupEventListeners() {
        if (!loadNftBtn) { console.error("Load button not found!"); return; } // Basic check

        // NFT Loading
        loadNftBtn.addEventListener('click', loadNftToCanvas);
        // Sign Color
        applyOverlayBtn.addEventListener('click', applyOverlay);
        overlayColorInput.addEventListener('input', applyOverlay);
        // Text Editing
        addTextBtn.addEventListener('click', addText);
        textInput.addEventListener("input", handleTextControlChange);
        textColor.addEventListener("input", handleTextControlChange);
        fontSize.addEventListener("input", handleTextControlChange);
        fontFamily.addEventListener("input", handleTextControlChange);
        // Image Editing
        addImageBtn.addEventListener('click', addImage);
        // Actions
        removeBtn.addEventListener('click', removeActiveElement);
        saveBtn.addEventListener('click', saveImage);
        resetCanvasBtn.addEventListener('click', handleReset);
        // Collection Change
         nftCollectionSelect.addEventListener("change", () => { if (baseImage.src && baseImage.complete) { applyOverlay(); } });
    }

    // --- Event Handlers ---
     function handleTextControlChange() { if(activeElement&&activeElement.classList.contains('textOverlay')){activeElement.childNodes[0].nodeValue=textInput.value;activeElement.style.color=textColor.value;activeElement.style.fontSize=fontSize.value+"px";activeElement.style.fontFamily=fontFamily.value;} }
     function handleReset() { if(confirm("Are you sure you want to clear the canvas and all added elements? This cannot be undone.")){clearCanvasAndOverlays();if(baseImage.src&&baseImage.complete&&baseImage.naturalWidth>0){drawBaseImage();applyOverlay();enableEditingControls(true);}else{enableEditingControls(false);nftStatusEl.textContent="Select collection and ID, then load NFT.";nftStatusEl.className='';}} }

    // --- Canvas & Overlay Management ---
    function clearCanvasAndOverlays() { ctx.clearRect(0,0,canvasWidth,canvasHeight); ctx.fillStyle='#444'; ctx.fillRect(0,0,canvasWidth,canvasHeight); container.querySelectorAll('.textOverlay, .imgOverlay').forEach(el=>el.remove()); setActiveElement(null); nftStatusEl.textContent="Canvas Cleared."; nftStatusEl.className=''; }
    function clearCanvas() { ctx.clearRect(0,0,canvasWidth,canvasHeight); ctx.fillStyle='#444'; ctx.fillRect(0,0,canvasWidth,canvasHeight); }
    function enableEditingControls(isEnabled) { [overlayColorInput,applyOverlayBtn,textInput,textColor,fontSize,fontFamily,addTextBtn,saveBtn,imageUpload,addImageBtn,removeBtn].forEach(el=>{if(el)el.disabled=!isEnabled;}); updateControlState(); }
    function updateControlState() { const isElementActive=activeElement!==null; const isTextActive=isElementActive&&activeElement.classList.contains('textOverlay'); const isImageLoaded=baseImage.src!==""&&baseImage.complete&&baseImage.naturalWidth>0; if(textInput)textInput.disabled=!isTextActive||!isImageLoaded; if(textColor)textColor.disabled=!isTextActive||!isImageLoaded; if(fontSize)fontSize.disabled=!isTextActive||!isImageLoaded; if(fontFamily)fontFamily.disabled=!isTextActive||!isImageLoaded; if(overlayColorInput)overlayColorInput.disabled=!isImageLoaded; if(applyOverlayBtn)applyOverlayBtn.disabled=!isImageLoaded; if(addTextBtn)addTextBtn.disabled=!isImageLoaded; if(imageUpload)imageUpload.disabled=!isImageLoaded; if(addImageBtn)addImageBtn.disabled=!isImageLoaded; if(saveBtn)saveBtn.disabled=!isImageLoaded; if(removeBtn)removeBtn.disabled=!isElementActive||!isImageLoaded; }

    // --- NFT Loading & Drawing ---
    function getPolygonForSelectedCollection(){const selectedCollection=nftCollectionSelect.value;if(selectedCollection==="AHC"){return[{x:1415,y:316},{x:2024,y:358},{x:1958,y:1324},{x:1358,y:1286}];}else{return[{x:1403,y:196},{x:2034,y:218},{x:1968,y:1164},{x:1358,y:1126}];}}
    function resolveIpfsUrl(url) { if(url&&url.startsWith("ipfs://")){return url.replace("ipfs://","https://ipfs.io/ipfs/");}return url;}
    async function loadNftToCanvas() {
        const selectedCollection = nftCollectionSelect.value; const tokenId = nftTokenIdInput.value;
        if (!tokenId) { nftStatusEl.textContent = "Please enter a Token ID."; nftStatusEl.className = 'error'; return; }
        if (!nftContracts[selectedCollection]) { nftStatusEl.textContent = "Invalid NFT collection selected."; nftStatusEl.className = 'error'; return; }
        loadNftBtn.disabled = true; enableEditingControls(false); clearCanvasAndOverlays();
        nftStatusEl.textContent = `Loading ${nftContracts[selectedCollection].name} #${tokenId}...`; nftStatusEl.className = '';
        const contractInfo = nftContracts[selectedCollection]; const contract = new ethers.Contract(contractInfo.address, nftAbi, provider);
        try {
            let tokenURI = await contract.tokenURI(tokenId); tokenURI = resolveIpfsUrl(tokenURI);
            nftStatusEl.textContent = "Fetching metadata...";
            const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 20000);
            const response = await fetch(tokenURI, { signal: controller.signal }); clearTimeout(timeoutId);
            if (!response.ok) throw new Error(`Metadata error: ${response.status} ${response.statusText} (URL: ${tokenURI})`);
            const metadata = await response.json();
            let imageUrl = resolveIpfsUrl(metadata.image || metadata.image_url || metadata.imageUrl);
            if (!imageUrl) throw new Error("Image URL missing in metadata");
            nftStatusEl.textContent = "Loading image..."; baseImage = new Image(); baseImage.crossOrigin = "Anonymous";
            baseImage.onload = () => {
                nftStatusEl.textContent = "Drawing image..."; drawBaseImage();
                nftStatusEl.textContent = `${nftContracts[selectedCollection].name} #${tokenId} loaded successfully!`; nftStatusEl.className = 'success';
                enableEditingControls(true); loadNftBtn.disabled = false; applyOverlay();
            };
            baseImage.onerror = (err) => {
                console.error("Error loading NFT image:", err, "Attempted URL:", imageUrl); nftStatusEl.textContent = `Error loading image. Check console for details.`; nftStatusEl.className = 'error';
                loadNftBtn.disabled = false; clearCanvasAndOverlays(); ctx.fillStyle = "white"; ctx.font = "30px Arial"; ctx.textAlign = "center"; ctx.fillText("Image Load Error", canvasWidth / 2, canvasHeight / 2);
            }; baseImage.src = imageUrl;
        } catch (err) {
            console.error(`Error processing NFT ${tokenId}:`, err); let errorMsg = "Error: " + err.message;
            if (err.name === 'AbortError') { errorMsg = "Error: Metadata request timed out."; }
            else if (err.message?.includes('invalid token ID')) { errorMsg = `Error: Token ID ${tokenId} invalid or does not exist.`; }
             else if (err.message?.includes('CALL_EXCEPTION')) { errorMsg = `Error: Could not query contract. Check network/address.`; }
            nftStatusEl.textContent = errorMsg; nftStatusEl.className = 'error'; loadNftBtn.disabled = false; clearCanvasAndOverlays();
            ctx.fillStyle = "white"; ctx.font = "30px Arial"; ctx.textAlign = "center"; ctx.fillText("NFT Load Error", canvasWidth / 2, canvasHeight / 2);
        }
     }
    function drawBaseImage() { if(!baseImage.src||!baseImage.complete||baseImage.naturalWidth===0)return; const aspectRatio=baseImage.naturalWidth/baseImage.naturalHeight; let drawWidth=canvasWidth,drawHeight=canvasHeight,x=0,y=0; if(canvasWidth/canvasHeight>aspectRatio){drawHeight=canvasHeight;drawWidth=drawHeight*aspectRatio;x=(canvasWidth-drawWidth)/2;}else{drawWidth=canvasWidth;drawHeight=drawWidth/aspectRatio;y=(canvasHeight-drawHeight)/2;} ctx.clearRect(0,0,canvasWidth,canvasHeight); ctx.fillStyle="#444"; ctx.fillRect(0,0,canvasWidth,canvasHeight); try{ctx.drawImage(baseImage,x,y,drawWidth,drawHeight);}catch(e){console.error("Error drawing base image:",e); nftStatusEl.textContent="Error drawing NFT image."; nftStatusEl.className='error';} }
    function applyOverlay() { if(!baseImage.src||!baseImage.complete||baseImage.naturalWidth===0)return; drawBaseImage(); const color=overlayColorInput.value; const currentPolygon=getPolygonForSelectedCollection(); ctx.beginPath(); ctx.moveTo(currentPolygon[0].x,currentPolygon[0].y); for(let i=1;i<currentPolygon.length;i++)ctx.lineTo(currentPolygon[i].x,currentPolygon[i].y); ctx.closePath(); ctx.fillStyle=color; ctx.fill(); ctx.lineJoin="round"; ctx.lineWidth=14; ctx.strokeStyle="black"; ctx.stroke(); }

    // --- Text & Image Creation ---
    function addText() {
        if(!baseImage.src||!baseImage.complete||baseImage.naturalWidth===0){nftStatusEl.textContent="Load a valid NFT first.";nftStatusEl.className='error';return;}
        const textEl=document.createElement("div");textEl.className="textOverlay";textEl.innerText=textInput.value||"New Text";textEl.style.color=textColor.value;textEl.style.fontSize=fontSize.value+"px";textEl.style.fontFamily=fontFamily.value;textEl.style.transform=`translate(-50%, -50%) rotate(0deg)`;textEl.style.zIndex="10";const handle=document.createElement("span");handle.className="rotation-handle";handle.innerHTML='&#x21BA;';textEl.appendChild(handle);const currentPolygon=getPolygonForSelectedCollection();const minX=Math.min(...currentPolygon.map(p=>p.x));const maxX=Math.max(...currentPolygon.map(p=>p.x));const minY=Math.min(...currentPolygon.map(p=>p.y));const maxY=Math.max(...currentPolygon.map(p=>p.y));const signCenterXPercent=canvasWidth?((minX+maxX)/2)/canvasWidth*100:50;const signCenterYPercent=canvasHeight?((minY+maxY)/2)/canvasHeight*100:50;const{x:initialX,y:initialY}=calculateElementPosition(signCenterXPercent,signCenterYPercent);textEl.style.left=`${initialX}px`;textEl.style.top=`${initialY}px`;textEl.addEventListener("mousedown",handleTextDragStart);textEl.addEventListener("touchstart",handleTextDragStart,{passive:true});handle.addEventListener("mousedown",handleTextRotateStart);handle.addEventListener("touchstart",handleTextRotateStart,{passive:true});container.appendChild(textEl);setActiveElement(textEl);
    }
    function addImage() {
        if(!baseImage.src||!baseImage.complete||baseImage.naturalWidth===0){nftStatusEl.textContent="Please load a valid NFT first.";nftStatusEl.className='error';return;}
        if(!imageUpload.files||imageUpload.files.length===0){nftStatusEl.textContent="Please select an image file.";nftStatusEl.className='error';return;}
        const file=imageUpload.files[0];const reader=new FileReader();
        reader.onload=function(e){const wrapper=document.createElement("div");wrapper.className="imgOverlay";wrapper.style.position="absolute";wrapper.style.width="auto";wrapper.style.height="auto";wrapper.style.transform="translate(-50%, -50%) rotate(0deg)";wrapper.style.touchAction="none";wrapper.style.zIndex="20";const img=document.createElement("img");img.src=e.target.result;
        img.onload=()=>{if(container.offsetWidth>0&&img.naturalWidth>0&&img.naturalHeight>0){const contW=container.offsetWidth;const initialWidth=Math.min(img.naturalWidth*0.60,contW*0.5,250);const aspectRatio=img.naturalWidth/img.naturalHeight;wrapper.style.width=`${initialWidth}px`;wrapper.style.height=`${initialWidth/aspectRatio}px`;}else{wrapper.style.width='100px';wrapper.style.height='auto';}};
        img.onerror=()=>{console.error("Error loading added image.");nftStatusEl.textContent="Error displaying uploaded image.";nftStatusEl.className='error';wrapper.remove();}
        wrapper.appendChild(img);const rotateHandle=document.createElement("div");rotateHandle.className="rotation-handle";rotateHandle.innerHTML='&#x21BA;';wrapper.appendChild(rotateHandle);const resizeHandle=document.createElement("div");resizeHandle.className="resize-handle";resizeHandle.innerHTML='&#x2194;';wrapper.appendChild(resizeHandle);const currentPolygon=getPolygonForSelectedCollection();const minX=Math.min(...currentPolygon.map(p=>p.x));const maxX=Math.max(...currentPolygon.map(p=>p.x));const minY=Math.min(...currentPolygon.map(p=>p.y));const maxY=Math.max(...currentPolygon.map(p=>p.y));const signCenterXPercent=canvasWidth?((minX+maxX)/2)/canvasWidth*100:50;const signCenterYPercent=canvasHeight?((minY+maxY)/2)/canvasHeight*100:50;const{x:initialX,y:initialY}=calculateElementPosition(signCenterXPercent,signCenterYPercent);wrapper.style.left=`${initialX}px`;wrapper.style.top=`${initialY}px`;wrapper.addEventListener("mousedown",handleImageDragStart);wrapper.addEventListener("touchstart",handleImageDragStart,{passive:true});rotateHandle.addEventListener("mousedown",handleImageRotateStart);rotateHandle.addEventListener("touchstart",handleImageRotateStart,{passive:true});resizeHandle.addEventListener("mousedown",handleImageResizeStart);resizeHandle.addEventListener("touchstart",handleImageResizeStart,{passive:true});container.appendChild(wrapper);setActiveElement(wrapper);nftStatusEl.textContent="Image added.";nftStatusEl.className='success';imageUpload.value='';};
        reader.onerror=function(err){console.error("FileReader error:",err);nftStatusEl.textContent="Error reading image file.";nftStatusEl.className='error';}
        reader.readAsDataURL(file);
    }

    // --- Active Element Management & Removal ---
    function setActiveElement(el) { if(activeElement&&activeElement!==el){activeElement.classList.remove("active");activeElement.style.zIndex=activeElement.classList.contains('imgOverlay')?'20':'10';} if(el){el.classList.add("active");activeElement=el;el.style.zIndex=el.classList.contains('imgOverlay')?'101':'100';if(el.classList.contains('textOverlay')){textInput.value=el.childNodes[0].nodeValue;textColor.value=rgb2hex(el.style.color);fontSize.value=parseInt(el.style.fontSize);const currentFont=el.style.fontFamily.split(',')[0].replace(/['"]/g,"").trim();let foundFont=false;for(let option of fontFamily.options){if(option.value.includes(currentFont)){fontFamily.value=option.value;foundFont=true;break;}}if(!foundFont)fontFamily.value='Arial';}}else{activeElement=null;} updateControlState();}
    function removeActiveElement() { if(activeElement){activeElement.remove();setActiveElement(null);} }

    // --- Interaction Handlers ---
    function getEventCoordinates(event) { let x,y; if(event.touches&&event.touches.length>0){x=event.touches[0].clientX;y=event.touches[0].clientY;}else if(event.changedTouches&&event.changedTouches.length>0){x=event.changedTouches[0].clientX;y=event.changedTouches[0].clientY;}else{x=event.clientX;y=event.clientY;} return{x,y}; }
    function handleTextDragStart(event) { if(event.target.classList.contains('rotation-handle'))return;const el=event.currentTarget;setActiveElement(el);textInteractionState.isDragging=true;textInteractionState.isRotating=false;el.style.cursor='grabbing';document.body.style.cursor='grabbing';const coords=getEventCoordinates(event);const contRect=container.getBoundingClientRect();textInteractionState.startX=coords.x-contRect.left;textInteractionState.startY=coords.y-contRect.top;textInteractionState.startLeft=parseFloat(el.style.left||"0");textInteractionState.startTop=parseFloat(el.style.top||"0");document.addEventListener("mousemove",handleTextInteractionMove);document.addEventListener("mouseup",handleTextInteractionEnd);document.addEventListener("touchmove",handleTextInteractionMove,{passive:false});document.addEventListener("touchend",handleTextInteractionEnd);document.addEventListener("touchcancel",handleTextInteractionEnd);if(event.type==='mousedown')event.preventDefault();}
    function handleTextRotateStart(event) { event.stopPropagation();const el=event.currentTarget.parentElement;setActiveElement(el);textInteractionState.isRotating=true;textInteractionState.isDragging=false;document.body.style.cursor='alias';const coords=getEventCoordinates(event);const rect=el.getBoundingClientRect();textInteractionState.rotateCenterX=rect.left+rect.width/2;textInteractionState.rotateCenterY=rect.top+rect.height/2;const dx=coords.x-textInteractionState.rotateCenterX;const dy=coords.y-textInteractionState.rotateCenterY;let startAngle=Math.atan2(dy,dx);const currentRotationRad=getRotationRad(el);textInteractionState.rotateStartAngle=startAngle-currentRotationRad;document.addEventListener("mousemove",handleTextInteractionMove);document.addEventListener("mouseup",handleTextInteractionEnd);document.addEventListener("touchmove",handleTextInteractionMove,{passive:false});document.addEventListener("touchend",handleTextInteractionEnd);document.addEventListener("touchcancel",handleTextInteractionEnd);if(event.type==='mousedown')event.preventDefault();}
    function handleTextInteractionMove(event) { if(!activeElement||!activeElement.classList.contains('textOverlay')||(!textInteractionState.isDragging&&!textInteractionState.isRotating))return; if(event.type==='touchmove')event.preventDefault(); const coords=getEventCoordinates(event); const contRect=container.getBoundingClientRect(); if(textInteractionState.isDragging){const currentX=coords.x-contRect.left; const currentY=coords.y-contRect.top; let potentialNewLeft=textInteractionState.startLeft+(currentX-textInteractionState.startX); let potentialNewTop=textInteractionState.startTop+(currentY-textInteractionState.startY); const{canvasX,canvasY}=getCanvasCoordsFromContainerPoint(potentialNewLeft,potentialNewTop); if(pointInPolygon({x:canvasX,y:canvasY},getPolygonForSelectedCollection())){activeElement.style.left=`${potentialNewLeft}px`; activeElement.style.top=`${potentialNewTop}px`;}}else if(textInteractionState.isRotating){const dx=coords.x-textInteractionState.rotateCenterX; const dy=coords.y-textInteractionState.rotateCenterY; let angle=Math.atan2(dy,dx); let rotationRad=angle-textInteractionState.rotateStartAngle; let rotationDeg=rotationRad*(180/Math.PI); activeElement.style.transform=`translate(-50%, -50%) rotate(${rotationDeg}deg)`;}}
    function handleTextInteractionEnd(event) { if(activeElement&&activeElement.classList.contains('textOverlay')){activeElement.style.cursor='grab';} document.body.style.cursor='default'; textInteractionState.isDragging=false; textInteractionState.isRotating=false; document.removeEventListener("mousemove",handleTextInteractionMove); document.removeEventListener("mouseup",handleTextInteractionEnd); document.removeEventListener("touchmove",handleTextInteractionMove); document.removeEventListener("touchend",handleTextInteractionEnd); document.removeEventListener("touchcancel",handleTextInteractionEnd); }
    function handleImageDragStart(event) { if(event.target.classList.contains('rotation-handle')||event.target.classList.contains('resize-handle'))return;const el=event.currentTarget;setActiveElement(el);imageInteractionState.isDragging=true;imageInteractionState.isRotating=false;imageInteractionState.isResizing=false;el.style.cursor='grabbing';document.body.style.cursor='grabbing';const coords=getEventCoordinates(event);const contRect=container.getBoundingClientRect();imageInteractionState.startX=coords.x-contRect.left;imageInteractionState.startY=coords.y-contRect.top;imageInteractionState.startLeft=parseFloat(el.style.left||"0");imageInteractionState.startTop=parseFloat(el.style.top||"0");document.addEventListener("mousemove",handleImageInteractionMove);document.addEventListener("mouseup",handleImageInteractionEnd);document.addEventListener("touchmove",handleImageInteractionMove,{passive:false});document.addEventListener("touchend",handleImageInteractionEnd);document.addEventListener("touchcancel",handleImageInteractionEnd);if(event.type==='mousedown')event.preventDefault();}
    function handleImageRotateStart(event) { event.stopPropagation();const el=event.currentTarget.parentElement;setActiveElement(el);imageInteractionState.isRotating=true;imageInteractionState.isDragging=false;imageInteractionState.isResizing=false;document.body.style.cursor='alias';const coords=getEventCoordinates(event);const rect=el.getBoundingClientRect();imageInteractionState.centerX=rect.left+rect.width/2;imageInteractionState.centerY=rect.top+rect.height/2;const dx=coords.x-imageInteractionState.centerX;const dy=coords.y-imageInteractionState.centerY;let startAngle=Math.atan2(dy,dx);imageInteractionState.currentRotationRad=getRotationRad(el);imageInteractionState.startAngle=startAngle-imageInteractionState.currentRotationRad;document.addEventListener("mousemove",handleImageInteractionMove);document.addEventListener("mouseup",handleImageInteractionEnd);document.addEventListener("touchmove",handleImageInteractionMove,{passive:false});document.addEventListener("touchend",handleImageInteractionEnd);document.addEventListener("touchcancel",handleImageInteractionEnd);if(event.type==='mousedown')event.preventDefault();}
    function handleImageResizeStart(event) { event.stopPropagation();const el=event.currentTarget.parentElement;setActiveElement(el);imageInteractionState.isResizing=true;imageInteractionState.isRotating=false;imageInteractionState.isDragging=false;document.body.style.cursor='nwse-resize';const coords=getEventCoordinates(event);imageInteractionState.startX=coords.x;imageInteractionState.startY=coords.y;imageInteractionState.startWidth=el.offsetWidth;imageInteractionState.startHeight=el.offsetHeight;imageInteractionState.aspectRatio=imageInteractionState.startHeight>0?imageInteractionState.startWidth/imageInteractionState.startHeight:1;imageInteractionState.currentRotationRad=getRotationRad(el);const rect=el.getBoundingClientRect();imageInteractionState.centerX=rect.left+rect.width/2;imageInteractionState.centerY=rect.top+rect.height/2;document.addEventListener("mousemove",handleImageInteractionMove);document.addEventListener("mouseup",handleImageInteractionEnd);document.addEventListener("touchmove",handleImageInteractionMove,{passive:false});document.addEventListener("touchend",handleImageInteractionEnd);document.addEventListener("touchcancel",handleImageInteractionEnd);if(event.type==='mousedown')event.preventDefault();}
    function handleImageInteractionMove(event) { if(!activeElement||!activeElement.classList.contains('imgOverlay')||(!imageInteractionState.isDragging&&!imageInteractionState.isRotating&&!imageInteractionState.isResizing))return; if(event.type==='touchmove')event.preventDefault(); const coords=getEventCoordinates(event); const contRect=container.getBoundingClientRect(); if(imageInteractionState.isDragging){const currentX=coords.x-contRect.left;const currentY=coords.y-contRect.top;let potentialNewLeft=imageInteractionState.startLeft+(currentX-imageInteractionState.startX);let potentialNewTop=imageInteractionState.startTop+(currentY-imageInteractionState.startY);const{canvasX,canvasY}=getCanvasCoordsFromContainerPoint(potentialNewLeft,potentialNewTop);if(pointInPolygon({x:canvasX,y:canvasY},getPolygonForSelectedCollection())){activeElement.style.left=`${potentialNewLeft}px`;activeElement.style.top=`${potentialNewTop}px`;}}else if(imageInteractionState.isRotating){const dx=coords.x-imageInteractionState.centerX;const dy=coords.y-imageInteractionState.centerY;let angle=Math.atan2(dy,dx);let rotationRad=angle-imageInteractionState.startAngle;let rotationDeg=rotationRad*(180/Math.PI);activeElement.style.transform=`translate(-50%, -50%) rotate(${rotationDeg}deg)`;}else if(imageInteractionState.isResizing){const dx=coords.x-imageInteractionState.startX;const dy=coords.y-imageInteractionState.startY;const rotation=imageInteractionState.currentRotationRad;const cosR=Math.cos(rotation);const sinR=Math.sin(rotation);const rotatedDx=dx*cosR+dy*sinR;const diagonalFactor=Math.sqrt(2)/2;const effectiveDelta=rotatedDx*diagonalFactor;let newWidth=imageInteractionState.startWidth+effectiveDelta*2;newWidth=Math.max(30,newWidth);let newHeight=imageInteractionState.aspectRatio>0?newWidth/imageInteractionState.aspectRatio:newWidth;activeElement.style.width=`${newWidth}px`;activeElement.style.height=`${newHeight}px`;}}
    function handleImageInteractionEnd(event) { if(activeElement&&activeElement.classList.contains('imgOverlay')){activeElement.style.cursor='grab';} document.body.style.cursor='default'; imageInteractionState.isDragging=false; imageInteractionState.isRotating=false; imageInteractionState.isResizing=false; document.removeEventListener("mousemove",handleImageInteractionMove); document.removeEventListener("mouseup",handleImageInteractionEnd); document.removeEventListener("touchmove",handleImageInteractionMove); document.removeEventListener("touchend",handleImageInteractionEnd); document.removeEventListener("touchcancel",handleImageInteractionEnd); }

    // --- Utility Functions ---
    function calculateElementPosition(percentX,percentY){const contRect=container.getBoundingClientRect();if(!contRect||contRect.width===0||contRect.height===0)return{x:0,y:0};const scaleX=contRect.width/canvasWidth;const scaleY=contRect.height/canvasHeight;const targetCanvasX=canvasWidth*(percentX/100);const targetCanvasY=canvasHeight*(percentY/100);return{x:targetCanvasX*scaleX,y:targetCanvasY*scaleY};}
    function getCanvasCoordsFromContainerPoint(containerX,containerY){const contRect=container.getBoundingClientRect();if(!contRect||contRect.width===0||contRect.height===0)return{canvasX:0,canvasY:0};const scaleX=contRect.width/canvasWidth;const scaleY=contRect.height/canvasHeight;return{canvasX:containerX/scaleX,canvasY:containerY/scaleY};}
    function pointInPolygon(point,vs){const x=point.x,y=point.y;let inside=false;for(let i=0,j=vs.length-1;i<vs.length;j=i++){const xi=vs[i].x,yi=vs[i].y;const xj=vs[j].x,yj=vs[j].y;const intersect=((yi>y)!==(yj>y))&&(x<(xj-xi)*(y-yi)/(yj-yi)+xi);if(intersect)inside=!inside;}return inside;}
    function rgb2hex(rgb){if(!rgb)return'#ffffff';if(rgb.startsWith('#'))return rgb;const rgbMatch=rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);if(rgbMatch){return"#"+rgbMatch.slice(1).map(x=>parseInt(x).toString(16).padStart(2,'0')).join('');}return rgb;}
    function getRotationRad(element){if(!element||!element.style)return 0;const transform=element.style.transform;const rotateMatch=transform.match(/rotate\((-?\d+(\.\d+)?)deg\)/);const rotationDeg=rotateMatch?parseFloat(rotateMatch[1]):0;return rotationDeg*(Math.PI/180);}

    // --- Save Functionality ---
    function saveImage() {
        if(!baseImage.src||!baseImage.complete||baseImage.naturalWidth===0){alert("Load a valid NFT first!");nftStatusEl.className='error';return;}
        nftStatusEl.textContent="Generating final image...";nftStatusEl.className=''; if(activeElement)activeElement.classList.remove('active');
        drawBaseImage(); applyOverlay(); const currentContainerRect=container.getBoundingClientRect();
        if(!currentContainerRect||currentContainerRect.width===0||currentContainerRect.height===0){alert("Error: Invalid container dimensions for saving.");nftStatusEl.className='error'; nftStatusEl.textContent="Save Error: Invalid container."; if(activeElement)activeElement.classList.add('active');return;}
        const scaleX=currentContainerRect.width/canvasWidth; const scaleY=currentContainerRect.height/canvasHeight;
        const allOverlays=Array.from(container.querySelectorAll(".textOverlay, .imgOverlay"));
        allOverlays.sort((a,b)=>(parseInt(window.getComputedStyle(a).zIndex)||0)-(parseInt(window.getComputedStyle(b).zIndex)||0));
        allOverlays.forEach(el=>{const elLeft=parseFloat(el.style.left||"0");const elTop=parseFloat(el.style.top||"0");const{canvasX,canvasY}=getCanvasCoordsFromContainerPoint(elLeft,elTop);const rotationRad=getRotationRad(el);ctx.save();ctx.translate(canvasX,canvasY);ctx.rotate(rotationRad);if(el.classList.contains('textOverlay')){const text=el.childNodes[0].nodeValue;const color=el.style.color;const size=parseInt(el.style.fontSize);const font=el.style.fontFamily;const canvasFontSize=size/scaleY;ctx.font=`${canvasFontSize}px ${font}`;ctx.fillStyle=color;ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillText(text,0,0);}else if(el.classList.contains('imgOverlay')){const imgElement=el.querySelector('img');if(imgElement&&imgElement.complete&&imgElement.naturalWidth>0){const domWidth=el.offsetWidth;const domHeight=el.offsetHeight;const canvasDrawWidth=domWidth/scaleX;const canvasDrawHeight=domHeight/scaleY;ctx.drawImage(imgElement,-canvasDrawWidth/2,-canvasDrawHeight/2,canvasDrawWidth,canvasDrawHeight);}else{console.warn("Skipping unloaded/invalid image overlay during save:",imgElement?.src);}} ctx.restore();});
        if(activeElement)activeElement.classList.add('active');
        try{const dataURL=canvas.toDataURL("image/png");const link=document.createElement("a");const filename=`signed-${nftCollectionSelect.value}-${nftTokenIdInput.value}.png`;link.download=filename;link.href=dataURL;document.body.appendChild(link);link.click();document.body.removeChild(link);nftStatusEl.textContent=`Image saved as ${filename}!`;nftStatusEl.className='success';}catch(e){console.error("Error saving image:",e);if(e.name==="SecurityError"){alert("Save Error: Cannot save canvas due to cross-origin image security restrictions. Ensure NFT images allow cross-origin use (CORS).");nftStatusEl.textContent="Save Error: Cross-origin issue.";nftStatusEl.className='error';}else{alert("An error occurred while saving the image.");nftStatusEl.textContent="Save Error.";nftStatusEl.className='error';}}}

    // Minor JS adjustment: Ensure passive: true for touch listeners where preventDefault isn't called inside
    // Already done for drag/rotate starts, checking others... ok.

</script>
</body>
</html>
