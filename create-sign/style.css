// --- Global Constants ---
const canvasWidth = 2048;
const canvasHeight = 2048;
const nftContracts = {
    "GHN": { address: "0xe6d48bf4ee912235398b96e16db6f310c21e82cb", name: "GHN" },
    "AHC": { address: "0x9370045ce37f381500ac7d6802513bb89871e076", name: "AHC" }
};
const nftAbi = ["function tokenURI(uint256 tokenId) public view returns (string)"];
const provider = new ethers.JsonRpcProvider("https://eth.llamarpc.com");

// --- Supabase Setup ---
const SUPABASE_URL = 'https://nwhqhyjgxugrdakuaaps.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im53aHFoeWpneHVncmRha3VhYXBzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQwMTM3NzUsImV4cCI6MjA1OTU4OTc3NX0.zdaCBYkj87BeVShMgjzERAmzJZ5u6N2cCMSzGhY1-rs';
const SUPABASE_BUCKET_NAME = 'sign-gallery';
let supabase = null;
try {
    if (window.supabase && typeof window.supabase.createClient === 'function') {
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        console.log("Supabase client initialized.");
    } else {
        console.error("Supabase library not loaded correctly.");
        alert("Error: Could not initialize connection to the gallery service.");
    }
} catch (error) {
    console.error("Error initializing Supabase:", error);
    alert("Error: Could not initialize connection to the gallery service.");
}

// --- Global State ---
let baseImage = new Image();
let activeElement = null;
let textInteractionState = { isDragging: false, isRotating: false, startX: 0, startY: 0, startLeft: 0, startTop: 0, rotateCenterX: 0, rotateCenterY: 0, rotateStartAngle: 0 };
let imageInteractionState = { isDragging: false, isRotating: false, isResizing: false, startX: 0, startY: 0, startLeft: 0, startTop: 0, centerX: 0, centerY: 0, startAngle: 0, currentRotationRad: 0, startWidth: 0, startHeight: 0, aspectRatio: 1 };
// --- AUTH ---
let currentUser = null;

// --- DOM Element References ---
let canvas, ctx, container, textInput, textColor, fontSize, fontFamily, removeBtn, nftStatusEl,
    nftCollectionSelect, nftTokenIdInput, loadNftBtn, applyOverlayBtn, overlayColorInput,
    addTextBtn, addImageBtn, imageUpload, resetCanvasBtn,
    saveFullBtn, uploadSignBtn,
    disclaimerBtn, disclaimerModal, closeDisclaimerBtn,
    // --- AUTH MODAL ---
    authModal, closeAuthModalBtn, connectXModalBtn;

// --- Initialization ---
window.onload = () => {
    // Get Element References
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d", { willReadFrequently: true });
    container = document.getElementById("canvas-container");
    textInput = document.getElementById("textInput");
    textColor = document.getElementById("textColor");
    fontSize = document.getElementById("fontSize");
    fontFamily = document.getElementById("fontFamily");
    removeBtn = document.getElementById("removeBtn");
    nftStatusEl = document.getElementById("nftStatus");
    nftCollectionSelect = document.getElementById("nftCollection");
    nftTokenIdInput = document.getElementById("nftTokenId");
    loadNftBtn = document.getElementById("loadNftBtn");
    applyOverlayBtn = document.getElementById("applyOverlayBtn");
    overlayColorInput = document.getElementById("overlayColor");
    addTextBtn = document.getElementById("addTextBtn");
    imageUpload = document.getElementById("imageUpload");
    addImageBtn = document.getElementById("addImageBtn");
    resetCanvasBtn = document.getElementById("resetCanvas");
    saveFullBtn = document.getElementById("saveFullBtn");
    uploadSignBtn = document.getElementById("uploadSignBtn");
    disclaimerBtn = document.getElementById("disclaimerBtn");
    disclaimerModal = document.getElementById("disclaimerModal");
    closeDisclaimerBtn = document.getElementById("closeDisclaimerBtn");
    // --- AUTH MODAL ---
    authModal = document.getElementById("authModal");
    closeAuthModalBtn = document.getElementById("closeAuthModalBtn");
    connectXModalBtn = document.getElementById("connectXModalBtn");


    // Initial Setup
    enableEditingControls(false);
    clearCanvas();
    setupEventListeners();

    // --- AUTH --- Check initial auth state silently
    if (supabase) {
        checkUserSession();
        monitorAuthState();
    } else {
        // If Supabase failed, ensure upload button reflects this
        updateControlState();
    }
};

function setupEventListeners() {
    // Core Controls
    loadNftBtn.addEventListener('click', loadNftToCanvas);
    applyOverlayBtn.addEventListener('click', applyOverlay);
    overlayColorInput.addEventListener('input', applyOverlay);
    addTextBtn.addEventListener('click', addText);
    textInput.addEventListener("input", handleTextControlChange);
    textColor.addEventListener("input", handleTextControlChange);
    fontSize.addEventListener("input", handleTextControlChange);
    fontFamily.addEventListener("input", handleTextControlChange);
    addImageBtn.addEventListener('click', addImage);
    removeBtn.addEventListener('click', removeActiveElement);
    resetCanvasBtn.addEventListener('click', handleReset);
    nftCollectionSelect.addEventListener("change", () => { if (baseImage.src && baseImage.complete) { applyOverlay(); } });

    // Final Actions
    if (saveFullBtn) {
        saveFullBtn.addEventListener('click', saveFullImageLocally);
    }
    if (uploadSignBtn) {
        uploadSignBtn.addEventListener('click', handleUploadClick); // Changed to handler function
    }

    // Disclaimer Modal
    if (disclaimerBtn && disclaimerModal && closeDisclaimerBtn) {
        disclaimerBtn.addEventListener('click', showComicDisclaimer);
        closeDisclaimerBtn.addEventListener('click', hideComicDisclaimer);
        disclaimerModal.addEventListener('click', (event) => {
            if (event.target === disclaimerModal) { hideComicDisclaimer(); }
        });
    }

    // Prevent default drag behavior
    container.addEventListener('dragstart', (e) => e.preventDefault());

    // --- AUTH MODAL Listeners ---
    if (authModal && closeAuthModalBtn && connectXModalBtn) {
        closeAuthModalBtn.addEventListener('click', hideAuthModal);
        connectXModalBtn.addEventListener('click', () => {
            hideAuthModal(); // Hide modal before redirecting
            signInWithTwitter();
        });
        // Close modal if clicking outside the content
        authModal.addEventListener('click', (event) => {
            if (event.target === authModal) { hideAuthModal(); }
        });
    }
}

// --- AUTH Functions ---

async function checkUserSession() {
    if (!supabase) return;
    try {
        const { data: { session }, error } = await supabase.auth.getSession();
        if (error) throw error;
        currentUser = session ? session.user : null;
        // No UI update here, only update state
        updateControlState(); // Update buttons based on initial auth state
    } catch (error) {
        console.error("Error checking user session:", error);
        currentUser = null;
        updateControlState();
    }
}

function monitorAuthState() {
    if (!supabase) return;
    supabase.auth.onAuthStateChange((_event, session) => {
        console.log("Auth state changed:", _event, session);
        currentUser = session ? session.user : null;
        // Auth state change might happen after returning from X.
        // Re-evaluate control states.
        updateControlState();
        // If the user just logged in, maybe briefly show a success message?
        if (_event === 'SIGNED_IN') {
             nftStatusEl.textContent = `Connected as @${currentUser.user_metadata?.user_name || 'User'}! You can now upload.`;
             nftStatusEl.className = 'success';
             // Optionally auto-trigger upload if intent was stored, or just let them click again.
        } else if (_event === 'SIGNED_OUT') {
            nftStatusEl.textContent = "Signed out.";
            nftStatusEl.className = '';
        }
    });
}

async function signInWithTwitter() {
    if (!supabase) return;
    try {
        nftStatusEl.textContent = "Redirecting to X for authentication...";
        nftStatusEl.className = '';
        updateControlState(); // Disable buttons during redirect

        const { error } = await supabase.auth.signInWithOAuth({
            provider: 'twitter',
             options: { redirectTo: window.location.href } // Keep redirect to handle return correctly
        });

        if (error) throw error;
        // User is redirected. onAuthStateChange will fire upon return.
    } catch (error) {
        console.error("Error signing in with Twitter:", error);
        nftStatusEl.textContent = `Error connecting with X: ${error.message}`;
        nftStatusEl.className = 'error';
        updateControlState(); // Re-enable controls if redirect fails immediately
    }
}

// SignOut function might not be needed if there's no explicit sign-out button anymore,
// but keep it in case you add one later or for debugging.
async function signOut() {
    if (!supabase || !currentUser) return;
    try {
        nftStatusEl.textContent = "Signing out..."; nftStatusEl.className = ''; updateControlState();
        const { error } = await supabase.auth.signOut();
        if (error) throw error;
        // State update is handled by monitorAuthState
    } catch (error) {
        console.error("Error signing out:", error);
        nftStatusEl.textContent = `Error signing out: ${error.message}`; nftStatusEl.className = 'error';
        updateControlState();
    }
}

// --- AUTH MODAL Management ---
function showAuthModal() {
    if (authModal) {
        authModal.classList.add('visible');
    }
}

function hideAuthModal() {
    if (authModal) {
        authModal.classList.remove('visible');
    }
}

// --- End AUTH Functions ---


// --- Event Handlers ---
 function handleTextControlChange() { /* ... no changes ... */ }
 function handleReset() { /* ... no changes ... */ }

// --- Canvas & Overlay Management ---
function clearCanvasAndOverlays() { /* ... no changes ... */ }
function clearCanvas() { /* ... no changes ... */ }


// --- Control State Management ---
function enableEditingControls(isEnabled) {
    // Enables/disables based on NFT loaded state ONLY
    [overlayColorInput, applyOverlayBtn, textInput, textColor, fontSize, fontFamily,
     addTextBtn, imageUpload, addImageBtn, removeBtn, saveFullBtn
    ].forEach(el => { if (el) el.disabled = !isEnabled; });
    updateControlState(); // Always update final state
}

function updateControlState() {
    const isElementActive = activeElement !== null;
    const isTextActive = isElementActive && activeElement.classList.contains('textOverlay');
    const isImageLoaded = baseImage.src !== "" && baseImage.complete && baseImage.naturalWidth > 0;
    const isAuthenticated = currentUser !== null;
    const isLoading = nftStatusEl.textContent.includes('Loading') || nftStatusEl.textContent.includes('Fetching') || nftStatusEl.textContent.includes('Redirecting') || nftStatusEl.textContent.includes('Signing out') || nftStatusEl.textContent.includes('Generating');

    // Disable most editing controls if loading/auth process is happening or no NFT loaded
    const coreEditingDisabled = !isImageLoaded || isLoading;

    if (overlayColorInput) overlayColorInput.disabled = coreEditingDisabled;
    if (applyOverlayBtn) applyOverlayBtn.disabled = coreEditingDisabled;
    if (addTextBtn) addTextBtn.disabled = coreEditingDisabled;
    if (imageUpload) imageUpload.disabled = coreEditingDisabled;
    if (addImageBtn) addImageBtn.disabled = coreEditingDisabled;
    if (saveFullBtn) saveFullBtn.disabled = coreEditingDisabled;

    // Text controls need NFT loaded AND active text element (and not loading)
    if (textInput) textInput.disabled = coreEditingDisabled || !isTextActive;
    if (textColor) textColor.disabled = coreEditingDisabled || !isTextActive;
    if (fontSize) fontSize.disabled = coreEditingDisabled || !isTextActive;
    if (fontFamily) fontFamily.disabled = coreEditingDisabled || !isTextActive;

    // Remove button needs NFT loaded AND active element (and not loading)
    if (removeBtn) removeBtn.disabled = coreEditingDisabled || !isElementActive;

    // Upload button needs NFT loaded (and not loading) - auth check happens on click
    if (uploadSignBtn) {
        uploadSignBtn.disabled = coreEditingDisabled; // Disabled if no image or loading
        if (isLoading) {
             uploadSignBtn.title = "Processing...";
        } else if (!isImageLoaded) {
             uploadSignBtn.title = "Load an NFT first.";
        } else if (!isAuthenticated) {
            // If image loaded but not authenticated, tooltip hints at connection needed on click
            uploadSignBtn.title = "Click to Connect & Upload";
        } else {
            // Image loaded and authenticated
            uploadSignBtn.title = "Upload sign to gallery";
        }
    }

    // Load NFT button disabled only when actively loading
    if (loadNftBtn) loadNftBtn.disabled = isLoading;
}


// --- NFT Loading & Drawing ---
function getPolygonForSelectedCollection() { /* ... no changes ... */ }
function resolveIpfsUrl(url) { /* ... no changes ... */ }
async function loadNftToCanvas() { /* ... mostly no changes, ensures updateControlState is called ... */
    const selectedCollection = nftCollectionSelect.value; const tokenId = nftTokenIdInput.value;
    if (!tokenId) { nftStatusEl.textContent = "Please enter a Token ID."; nftStatusEl.className = 'error'; return; }
    if (!nftContracts[selectedCollection]) { nftStatusEl.textContent = "Invalid NFT collection selected."; nftStatusEl.className = 'error'; return; }

    nftStatusEl.textContent = `Loading ${nftContracts[selectedCollection].name} #${tokenId}...`; nftStatusEl.className = '';
    enableEditingControls(false); updateControlState(); // Set loading state
    clearCanvasAndOverlays();
    const contractInfo = nftContracts[selectedCollection]; const contract = new ethers.Contract(contractInfo.address, nftAbi, provider);
    try {
        let tokenURI = await contract.tokenURI(tokenId); tokenURI = resolveIpfsUrl(tokenURI);
        nftStatusEl.textContent = "Fetching metadata..."; updateControlState();
        const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), 20000);
        const response = await fetch(tokenURI, { signal: controller.signal }); clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`Metadata error: ${response.status} ${response.statusText} (URL: ${tokenURI})`);
        const metadata = await response.json(); let imageUrl = resolveIpfsUrl(metadata.image || metadata.image_url || metadata.imageUrl);
        if (!imageUrl) throw new Error("Image URL missing in metadata");
        nftStatusEl.textContent = "Loading image..."; updateControlState();
        baseImage = new Image(); baseImage.crossOrigin = "Anonymous";
        await new Promise((resolve, reject) => {
            baseImage.onload = () => {
                nftStatusEl.textContent = "Drawing image..."; updateControlState(); drawBaseImage();
                nftStatusEl.textContent = `${nftContracts[selectedCollection].name} #${tokenId} loaded successfully!`; nftStatusEl.className = 'success';
                enableEditingControls(true); applyOverlay();
                resolve();
            };
            baseImage.onerror = (err) => {
                console.error("Error loading NFT image:", err, "Attempted URL:", imageUrl); nftStatusEl.textContent = `Error loading image. Check console.`; nftStatusEl.className = 'error';
                clearCanvasAndOverlays(); ctx.fillStyle = "white"; ctx.font = "30px Arial"; ctx.textAlign = "center"; ctx.fillText("Image Load Error", canvasWidth / 2, canvasHeight / 2);
                reject(new Error('Image load failed'));
            }; baseImage.src = imageUrl;
        });
    } catch (err) {
        console.error(`Error processing NFT ${tokenId}:`, err); let errorMsg = "Error: " + err.message;
        if (err.name === 'AbortError') { errorMsg = "Error: Metadata request timed out."; }
        else if (err.code === 'CALL_EXCEPTION') { /* ... */ } else if (err.message?.includes('Metadata error')) { /* ... */ }
        nftStatusEl.textContent = errorMsg; nftStatusEl.className = 'error';
        clearCanvasAndOverlays(); ctx.fillStyle = "white"; ctx.font = "30px Arial"; ctx.textAlign = "center"; ctx.fillText("NFT Load Error", canvasWidth / 2, canvasHeight / 2);
    } finally {
         updateControlState(); // Ensure loading state removed
    }
 }
function drawBaseImage() { /* ... no changes ... */ }
function applyOverlay() { /* ... no changes ... */ }
function drawSignPolygonOnly() { /* ... no changes ... */ }


// --- Text & Image Creation ---
function addText() { /* ... no changes ... */ }
function addImage() { /* ... no changes ... */ }
function positionElementOnSign(element) { /* ... no changes ... */ }


// --- Active Element Management & Removal ---
function setActiveElement(el) { /* ... no changes ... */ }
function removeActiveElement() { /* ... no changes ... */ }


// --- Interaction Handlers ---
function getEventCoordinates(event) { /* ... no changes ... */ }
function handleTextDragStart(event) { /* ... no changes ... */ }
function handleTextRotateStart(event) { /* ... no changes ... */ }
function handleTextInteractionMove(event) { /* ... no changes ... */ }
function handleTextInteractionEnd(event) { /* ... no changes ... */ }
function handleImageDragStart(event) { /* ... no changes ... */ }
function handleImageRotateStart(event) { /* ... no changes ... */ }
function handleImageResizeStart(event) { /* ... no changes ... */ }
function handleImageInteractionMove(event) { /* ... no changes ... */ }
function handleImageInteractionEnd(event) { /* ... no changes ... */ }


// --- Utility Functions ---
function calculateElementPosition(percentX, percentY){ /* ... no changes ... */ }
function getCanvasCoordsFromContainerPoint(containerX_px, containerY_px){ /* ... corrected scale ... */ const contRect = container.getBoundingClientRect();if(!contRect||contRect.width===0||contRect.height===0)return{canvasX:0,canvasY:0}; const scaleX = canvasWidth / contRect.width; const scaleY = canvasHeight / contRect.height; return{canvasX:containerX_px * scaleX, canvasY:containerY_px * scaleY}; }
function pointInPolygon(point, vs){ /* ... no changes ... */ }
function rgb2hex(rgb){ /* ... no changes ... */ }
function getRotationRad(element){ /* ... no changes ... */ }


// --- DISCLAIMER Functions ---
function showComicDisclaimer() { /* ... no changes ... */ }
function hideComicDisclaimer() { /* ... no changes ... */ }


// --- Drawing Overlays onto Canvas Helper ---
function drawOverlaysToCanvas(targetCtx, targetCanvasWidth, targetCanvasHeight) { /* ... corrected scaling for font/image ... */
    const canvasRect = canvas.getBoundingClientRect();
    if (!canvasRect || canvasRect.width === 0 || canvasRect.height === 0) { console.error("Cannot draw overlays: Invalid canvas dimensions."); return false; }
    const scaleX = targetCanvasWidth / canvasRect.width;
    const scaleY = targetCanvasHeight / canvasRect.height;
    const allOverlays = Array.from(container.querySelectorAll(".textOverlay, .imgOverlay"));
    allOverlays.sort((a, b) => (parseInt(window.getComputedStyle(a).zIndex) || 0) - (parseInt(window.getComputedStyle(b).zIndex) || 0));
    allOverlays.forEach(el => {
        const elRect = el.getBoundingClientRect();
        const elCenterX_viewport = elRect.left + elRect.width / 2; const elCenterY_viewport = elRect.top + elRect.height / 2;
        const relativeCenterX = elCenterX_viewport - canvasRect.left; const relativeCenterY = elCenterY_viewport - canvasRect.top;
        const canvasX = Math.round(relativeCenterX * scaleX); const canvasY = Math.round(relativeCenterY * scaleY);
        const rotationRad = getRotationRad(el);
        targetCtx.save(); targetCtx.translate(canvasX, canvasY); targetCtx.rotate(rotationRad);
        if(el.classList.contains('textOverlay')){
            const text=el.childNodes[0].nodeValue; const color=el.style.color; const size=parseInt(el.style.fontSize); const font=el.style.fontFamily;
            const canvasFontSize = Math.round(size * scaleY); // Scale font based on display height ratio
            targetCtx.font=`${canvasFontSize}px ${font}`; targetCtx.fillStyle=color; targetCtx.textAlign="center"; targetCtx.textBaseline="middle"; targetCtx.fillText(text, 0, 0);
        } else if(el.classList.contains('imgOverlay')){
            const imgElement=el.querySelector('img');
            if(imgElement&&imgElement.complete&&imgElement.naturalWidth>0){
                 const canvasDrawWidth = Math.round(el.offsetWidth * scaleX); // Scale based on displayed width
                 const canvasDrawHeight = Math.round(el.offsetHeight * scaleY); // Scale based on displayed height
                 if (canvasDrawWidth > 0 && canvasDrawHeight > 0) { targetCtx.drawImage(imgElement, -canvasDrawWidth / 2, -canvasDrawHeight / 2, canvasDrawWidth, canvasDrawHeight); }
            } else { console.warn("Skipping unloaded/invalid image overlay during draw:", imgElement?.src); }
        }
        targetCtx.restore();
    });
    return true;
}


// --- Save Full Image Locally ---
function saveFullImageLocally() { /* ... no changes ... */ }


// --- Upload Sign Handlers ---

function handleUploadClick() {
    // This function is now the entry point when the upload button is clicked.
    // It checks auth state and decides whether to show the modal or proceed.

    // Basic checks (NFT loaded? Already loading?) - redundant if button is disabled correctly, but safe to keep
    const isImageLoaded = baseImage.src !== "" && baseImage.complete && baseImage.naturalWidth > 0;
    const isLoading = nftStatusEl.textContent.includes('Loading') || nftStatusEl.textContent.includes('Generating');
    if (!isImageLoaded || isLoading) {
        console.warn("Upload button clicked but preconditions not met (should be disabled).");
        return; // Do nothing if NFT not loaded or already busy
    }

    if (currentUser) {
        // User is authenticated, proceed directly to upload logic
        uploadSignToGallery();
    } else {
        // User is not authenticated, show the connection modal
        showAuthModal();
    }
}

async function uploadSignToGallery() {
    // This function now ASSUMES the user is authenticated because handleUploadClick checked first.
    // We perform the actual generation and Supabase upload here.

    if (!currentUser) { // Double-check, should not happen if flow is correct
        console.error("UploadSignToGallery called without authenticated user!");
        showAuthModal(); // Show modal just in case
        return;
    }
    if (!supabase) { /* ... */ return; }

    const currentNftId = nftTokenIdInput.value || 'unknown';
    const currentCollection = nftCollectionSelect.value || 'unknown';
    const signColor = overlayColorInput.value;

    // Checks for NFT loaded / sign color applied (redundant due to button state, but safe)
    if (!baseImage.src || !baseImage.complete || baseImage.naturalWidth === 0) { /* ... */ return; }
    if (!signColor) { /* ... */ return; }

    nftStatusEl.textContent = `Generating sign image for upload...`; nftStatusEl.className = '';
    updateControlState(); // Disable buttons during generation/upload

    if (activeElement) activeElement.classList.remove('active');

    // --- Create Sign Image on Canvas ---
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    drawSignPolygonOnly();
    const overlaysDrawn = drawOverlaysToCanvas(ctx, canvasWidth, canvasHeight);

    const redrawFullView = () => {
        if (baseImage.src && baseImage.complete) { applyOverlay(); drawOverlaysToCanvas(ctx, canvasWidth, canvasHeight); }
        else { clearCanvas(); }
        if (activeElement) activeElement.classList.add('active');
        updateControlState(); // Re-enable buttons
    };

    if (!overlaysDrawn) { /* ... error handling ... */ redrawFullView(); return; }

    canvas.toBlob(async (blob) => {
        if (!blob) { /* ... error handling ... */ redrawFullView(); return; }

        // --- Perform Supabase Upload ---
        const timestamp = Date.now();
        const userId = currentUser.id;
        const userHandle = currentUser.user_metadata?.user_name || currentUser.user_metadata?.screen_name || 'unknown_user';
        const fileName = `sign-${currentCollection}-${currentNftId}-${userHandle}-${timestamp}.png`;
        const filePath = `${currentCollection}/${userId}/${fileName}`;

        nftStatusEl.textContent = `Uploading sign as @${userHandle}...`; nftStatusEl.className = '';
        updateControlState(); // Keep buttons disabled

        try {
            const { data, error } = await supabase.storage
                .from(SUPABASE_BUCKET_NAME)
                .upload(filePath, blob, { contentType: 'image/png', upsert: false });

            if (error) throw error;

            if (data) {
                console.log("Supabase upload successful:", data);
                nftStatusEl.textContent = `Sign uploaded successfully! (${fileName})`;
                nftStatusEl.className = 'success';
                // Optional DB Insert Logic Here (commented out for brevity)
            } else {
                 throw new Error("Upload completed without error, but no data returned.");
            }

        } catch (error) {
            console.error("Supabase upload error:", error);
            let errorMsg = "Upload Error: Failed to upload sign.";
             if (error.message?.includes('bucket not found')) { errorMsg = `Upload Error: Bucket '${SUPABASE_BUCKET_NAME}' not found.`; }
             else if (error.message?.includes('mime type')) { errorMsg = "Upload Error: Invalid image format."; }
             else if (error.message?.includes('Auth') || error.message?.includes('policy') || error.message?.includes('RLS')) { errorMsg = "Upload Error: Not authorized (Check Bucket Policies/RLS)."; }
             else if (error.code === 'PGRST116') { errorMsg = "Upload Error: Database Table/Schema issue?"; }
             else if (error.message?.includes('unique constraint')) { errorMsg = "Upload Error: Duplicate entry."; }
            alert(errorMsg + " Check console for details.");
            nftStatusEl.textContent = errorMsg; nftStatusEl.className = 'error';
        } finally {
             redrawFullView(); // ALWAYS redraw and update controls
        }

    }, 'image/png');

} // End uploadSignToGallery function